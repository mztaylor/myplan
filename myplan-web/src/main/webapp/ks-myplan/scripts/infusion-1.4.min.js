var fluid_1_4 = fluid_1_4 || {};
var fluid = fluid || fluid_1_4;
(function ($, fluid) {
    var NAMESPACE_KEY = "fluid-scoped-data";
    fluid.getScopedData = function (target, key) {
        var data = $(target).data(NAMESPACE_KEY);
        return data ? data[key] : undefined
    };
    fluid.setScopedData = function (target, key, value) {
        $(target).each(function () {
            var data = $.data(this, NAMESPACE_KEY) || {};
            data[key] = value;
            $.data(this, NAMESPACE_KEY, data)
        })
    };
    var lastFocusedElement = null;
    $(document).bind("focusin", function (event) {
        lastFocusedElement = event.target
    });
    fluid.getLastFocusedElement = function () {
        return lastFocusedElement
    }
    var ENABLEMENT_KEY = "enablement";
    fluid.enabled = function (target, state) {
        target = $(target);
        if (state === undefined) {
            return fluid.getScopedData(target, ENABLEMENT_KEY) !== false
        } else {
            $("*", target).add(target).each(function () {
                if (fluid.getScopedData(this, ENABLEMENT_KEY) !== undefined) {
                    fluid.setScopedData(this, ENABLEMENT_KEY, state)
                } else if (/select|textarea|input/i.test(this.nodeName)) {
                    $(this).prop("disabled", !state)
                }
            });
            fluid.setScopedData(target, ENABLEMENT_KEY, state)
        }
    };
    fluid.initEnablement = function (target) {
        fluid.setScopedData(target, ENABLEMENT_KEY, true)
    };
    function applyOp(node, func) {
        node = $(node);
        node.trigger("fluid-" + func);
        node[func]()
    }

    $.each(["focus", "blur"], function (i, name) {
        fluid[name] = function (elem) {
            applyOp(elem, name)
        }
    })
})(jQuery, fluid_1_4);
(function ($, fluid) {
    fluid.version = "Infusion 1.4";
    fluid.environment = {fluid:fluid};
    var globalObject = window || {};
    var softFailure = [true];
    fluid.describeActivity = function () {
        return[]
    };
    fluid.fail = function (message) {
        fluid.setLogging(true);
        fluid.log.apply(null, ["ASSERTION FAILED: "].concat(fluid.makeArray(arguments)).concat(fluid.describeActivity()));
        if (softFailure[0]) {
            throw new Error(message)
        } else {
            message.fail()
        }
    };
    fluid.pushSoftFailure = function (condition) {
        if (typeof(condition) === "boolean") {
            softFailure.unshift(condition)
        } else if (condition === -1) {
            softFailure.shift()
        }
    };
    fluid.notrycatch = false;
    fluid.tryCatch = function (tryfun, catchfun, finallyfun) {
        finallyfun = finallyfun || fluid.identity;
        if (fluid.notrycatch) {
            var togo = tryfun();
            finallyfun();
            return togo
        } else {
            try {
                return tryfun()
            } catch (e) {
                if (catchfun) {
                    catchfun(e)
                } else {
                    throw(e)
                }
            } finally {
                finallyfun()
            }
        }
    };
    fluid.expect = function (name, members, target) {
        fluid.transform(fluid.makeArray(members), function (key) {
            if (typeof target[key] === "undefined") {
                fluid.fail(name + " missing required parameter " + key)
            }
        })
    };
    var logging;
    fluid.isLogging = function () {
        return logging
    };
    fluid.setLogging = function (enabled) {
        if (typeof enabled === "boolean") {
            logging = enabled
        } else {
            logging = false
        }
    };
    fluid.applyHostFunction = function (obj, func, args) {
        if (func.apply) {
            func.apply(obj, args)
        } else {
            var applier = Function.prototype.bind.call(func, obj);
            applier.apply(obj, args)
        }
    };
    fluid.log = function (message) {
        if (logging) {
            var arg0 = fluid.renderTimestamp(new Date()) + ":  ";
            var args = [arg0].concat(fluid.makeArray(arguments));
            var str = args.join("");
            if (typeof(console) !== "undefined") {
                if (console.debug) {
                    fluid.applyHostFunction(console, console.debug, args)
                } else if (typeof(console.log) === "function") {
                    fluid.applyHostFunction(console, console.log, args)
                } else {
                    console.log(str)
                }
            } else if (typeof(YAHOO) !== "undefined") {
                YAHOO.log(str)
            } else if (typeof(opera) !== "undefined") {
                opera.postError(str)
            }
        }
    };
    fluid.wrap = function (obj) {
        return((!obj || obj.jquery) ? obj : $(obj))
    };
    fluid.unwrap = function (obj) {
        return obj && obj.jquery && obj.length === 1 ? obj[0] : obj
    };
    fluid.identity = function (arg) {
        return arg
    };
    fluid.isValue = function (value) {
        return value !== undefined && value !== null
    };
    fluid.isPrimitive = function (value) {
        var valueType = typeof(value);
        return!value || valueType === "string" || valueType === "boolean" || valueType === "number" || valueType === "function"
    };
    fluid.isDOMNode = function (obj) {
        return obj && typeof(obj.nodeType) === "number"
    };
    fluid.isArrayable = function (totest) {
        return totest && !fluid.isPrimitive(totest) && typeof(totest.length) === "number"
    };
    fluid.freshContainer = function (tocopy) {
        return fluid.isArrayable(tocopy) ? [] : {}
    };
    fluid.copy = function (tocopy) {
        if (fluid.isPrimitive(tocopy)) {
            return tocopy
        }
        return $.extend(true, fluid.freshContainer(tocopy), tocopy)
    };
    fluid.makeArray = function (arg) {
        if (arg === null || arg === undefined) {
            return[]
        } else {
            return $.makeArray(arg)
        }
    };
    function transformInternal(source, togo, key, args) {
        var transit = source[key];
        for (var j = 0; j < args.length - 1; ++j) {
            transit = args[j + 1](transit, key)
        }
        togo[key] = transit
    }

    fluid.transform = function (source) {
        var togo = fluid.freshContainer(source);
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                transformInternal(source, togo, i, arguments)
            }
        } else {
            for (var key in source) {
                transformInternal(source, togo, key, arguments)
            }
        }
        return togo
    };
    fluid.each = function (source, func) {
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                func(source[i], i)
            }
        } else {
            for (var key in source) {
                func(source[key], key)
            }
        }
    };
    fluid.find = function (source, func, deflt) {
        var disp;
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                disp = func(source[i], i);
                if (disp !== undefined) {
                    return disp
                }
            }
        } else {
            for (var key in source) {
                disp = func(source[key], key);
                if (disp !== undefined) {
                    return disp
                }
            }
        }
        return deflt
    };
    fluid.accumulate = function (list, fn, arg) {
        for (var i = 0; i < list.length; ++i) {
            arg = fn(list[i], arg, i)
        }
        return arg
    };
    fluid.remove_if = function (source, fn) {
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                if (fn(source[i], i)) {
                    source.splice(i, 1);
                    --i
                }
            }
        } else {
            for (var key in source) {
                if (fn(source[key], key)) {
                    delete source[key]
                }
            }
        }
        return source
    };
    fluid.filterKeys = function (toFilter, keys, exclude) {
        return fluid.remove_if($.extend({}, toFilter), function (value, key) {
            return exclude ^ ($.inArray(key, keys) === -1)
        })
    };
    fluid.censorKeys = function (toCensor, keys) {
        return fluid.filterKeys(toCensor, keys, true)
    };
    fluid.keys = function (obj) {
        var togo = [];
        fluid.each(obj, function (value, key) {
            togo.push(key)
        });
        return togo
    };
    fluid.contains = function (obj, value) {
        return obj ? fluid.find(obj, function (thisValue, key) {
            if (value === thisValue) {
                return true
            }
        }) : undefined
    };
    fluid.keyForValue = function (obj, value) {
        return fluid.find(obj, function (thisValue, key) {
            if (value === thisValue) {
                return key
            }
        })
    };
    fluid.findKeyInObject = fluid.keyForValue;
    fluid.arrayToHash = function (array) {
        var togo = {};
        fluid.each(array, function (el) {
            togo[el] = true
        });
        return togo
    };
    fluid.clear = function (target) {
        if (fluid.isArrayable(target)) {
            target.length = 0
        } else {
            for (var i in target) {
                delete target[i]
            }
        }
    };
    fluid.model = {};
    fluid.VALUE = {type:"fluid.marker", value:"VALUE"};
    fluid.NO_VALUE = {type:"fluid.marker", value:"NO_VALUE"};
    fluid.EXPAND = {type:"fluid.marker", value:"EXPAND"};
    fluid.EXPAND_NOW = {type:"fluid.marker", value:"EXPAND_NOW"};
    fluid.isMarker = function (totest, type) {
        if (!totest || typeof(totest) !== 'object' || totest.type !== "fluid.marker") {
            return false
        }
        if (!type) {
            return true
        }
        return totest === type
    };
    fluid.model.copyModel = function (target, source) {
        fluid.clear(target);
        $.extend(true, target, source)
    };
    fluid.model.parseEL = function (EL) {
        return EL === "" ? [] : String(EL).split('.')
    };
    fluid.model.composePath = function (prefix, suffix) {
        return prefix === "" ? suffix : (suffix === "" ? prefix : prefix + "." + suffix)
    };
    fluid.model.composeSegments = function () {
        return $.makeArray(arguments).join(".")
    };
    fluid.path = fluid.model.composeSegments;
    fluid.composePath = fluid.model.composePath;
    fluid.model.environmentStrategy = function (initEnvironment) {
        return{init:function () {
            var environment = initEnvironment;
            return function (root, segment, index) {
                var togo;
                if (environment && environment[segment]) {
                    togo = environment[segment]
                }
                environment = null;
                return togo
            }
        }}
    };
    fluid.model.defaultCreatorStrategy = function (root, segment) {
        if (root[segment] === undefined) {
            root[segment] = {};
            return root[segment]
        }
    };
    fluid.model.defaultFetchStrategy = function (root, segment) {
        return segment === "" ? root : root[segment]
    };
    fluid.model.funcResolverStrategy = function (root, segment) {
        if (root.resolvePathSegment) {
            return root.resolvePathSegment(segment)
        }
    };
    fluid.model.applyStrategy = function (strategy, root, segment, index) {
        if (typeof(strategy) === "function") {
            return strategy(root, segment, index)
        } else if (strategy && strategy.next) {
            return strategy.next(root, segment, index)
        }
    };
    fluid.model.initStrategy = function (baseStrategy, index, oldStrategies) {
        return baseStrategy.init ? baseStrategy.init(oldStrategies ? oldStrategies[index] : undefined) : baseStrategy
    };
    fluid.model.makeTrundler = function (root, config, oldStrategies) {
        var that = {root:root, strategies:fluid.isArrayable(config) ? config : fluid.transform(config.strategies, function (strategy, index) {
            return fluid.model.initStrategy(strategy, index, oldStrategies)
        })};
        that.trundle = function (EL, uncess) {
            uncess = uncess || 0;
            var newThat = fluid.model.makeTrundler(that.root, config, that.strategies);
            newThat.segs = fluid.model.parseEL(EL);
            newThat.index = 0;
            newThat.step(newThat.segs.length - uncess);
            return newThat
        };
        that.next = function () {
            if (!that.root) {
                return
            }
            var accepted;
            for (var i = 0; i < that.strategies.length; ++i) {
                var value = fluid.model.applyStrategy(that.strategies[i], that.root, that.segs[that.index], that.index);
                if (accepted === undefined) {
                    accepted = value
                }
            }
            if (accepted === fluid.NO_VALUE) {
                accepted = undefined
            }
            that.root = accepted;
            ++that.index
        };
        that.step = function (limit) {
            for (var i = 0; i < limit; ++i) {
                that.next()
            }
            that.last = that.segs[that.index]
        };
        return that
    };
    fluid.model.defaultSetConfig = {strategies:[fluid.model.funcResolverStrategy, fluid.model.defaultFetchStrategy, fluid.model.defaultCreatorStrategy]};
    fluid.model.trundleImpl = function (trundler, EL, config, uncess) {
        if (typeof(EL) === "string") {
            trundler = trundler.trundle(EL, uncess)
        } else {
            var key = EL.type || "default";
            var resolver = config.resolvers[key];
            if (!resolver) {
                fluid.fail("Unable to find resolver of type " + key)
            }
            trundler = resolver(EL, trundler) || {};
            if (EL.path && trundler.trundle && trundler.root !== undefined) {
                trundler = fluid.model.trundleImpl(trundler, EL.path, config, uncess)
            }
        }
        return trundler
    };
    fluid.model.trundle = function (root, EL, config, uncess) {
        EL = EL || "";
        config = config || fluid.model.defaultGetConfig;
        var trundler = fluid.model.makeTrundler(root, config);
        return fluid.model.trundleImpl(trundler, EL, config, uncess)
    };
    fluid.model.getPenultimate = function (root, EL, config) {
        return fluid.model.trundle(root, EL, config, 1)
    };
    fluid.set = function (root, EL, newValue, config) {
        config = config || fluid.model.defaultSetConfig;
        var trundler = fluid.model.getPenultimate(root, EL, config);
        trundler.root[trundler.last] = newValue
    };
    fluid.model.defaultGetConfig = {strategies:[fluid.model.funcResolverStrategy, fluid.model.defaultFetchStrategy]};
    fluid.get = function (root, EL, config) {
        return fluid.model.trundle(root, EL, config).root
    };
    fluid.model.setBeanValue = fluid.set;
    fluid.model.getBeanValue = fluid.get;
    fluid.getGlobalValue = function (path, env) {
        if (path) {
            env = env || fluid.environment;
            var envFetcher = fluid.model.environmentStrategy(env);
            return fluid.get(globalObject, path, {strategies:[envFetcher].concat(fluid.model.defaultGetConfig.strategies)})
        }
    };
    fluid.invokeGlobalFunction = function (functionPath, args, environment) {
        var func = fluid.getGlobalValue(functionPath, environment);
        if (!func) {
            fluid.fail("Error invoking global function: " + functionPath + " could not be located")
        } else {
            return func.apply(null, args)
        }
    };
    fluid.registerGlobalFunction = function (functionPath, func, env) {
        env = env || fluid.environment;
        var envFetcher = fluid.model.environmentStrategy(env);
        fluid.set(globalObject, functionPath, func, {strategies:[envFetcher].concat(fluid.model.defaultSetConfig.strategies)})
    };
    fluid.setGlobalValue = fluid.registerGlobalFunction;
    fluid.registerNamespace = function (naimspace, env) {
        env = env || fluid.environment;
        var existing = fluid.getGlobalValue(naimspace, env);
        if (!existing) {
            existing = {};
            fluid.setGlobalValue(naimspace, existing, env)
        }
        return existing
    };
    fluid.dumpEl = fluid.identity;
    fluid.renderTimestamp = fluid.identity;
    fluid.registerNamespace("fluid.event");
    fluid.generateUniquePrefix = function () {
        return(Math.floor(Math.random() * 1e12)).toString(36) + "-"
    };
    var fluid_prefix = fluid.generateUniquePrefix();
    var fluid_guid = 1;
    fluid.allocateGuid = function () {
        return fluid_prefix + (fluid_guid++)
    };
    fluid.event.identifyListener = function (listener) {
        if (typeof(listener) === "string") {
            return listener
        }
        if (!listener.$$guid) {
            listener.$$guid = fluid.allocateGuid()
        }
        return listener.$$guid
    };
    fluid.event.mapPriority = function (priority, count) {
        return(priority === null || priority === undefined ? -count : (priority === "last" ? -Number.MAX_VALUE : (priority === "first" ? Number.MAX_VALUE : priority)))
    };
    fluid.event.listenerComparator = function (recA, recB) {
        return recB.priority - recA.priority
    };
    fluid.event.sortListeners = function (listeners) {
        var togo = [];
        fluid.each(listeners, function (listener) {
            togo.push(listener)
        });
        return togo.sort(fluid.event.listenerComparator)
    };
    fluid.event.getEventFirer = function (unicast, preventable) {
        var listeners = {};
        var sortedListeners = [];

        function fireToListeners(listeners, args, wrapper) {
            for (var i in listeners) {
                var lisrec = listeners[i];
                var listener = lisrec.listener;
                if (typeof(listener) === "string") {
                    var listenerFunc = fluid.getGlobalValue(listener);
                    if (!listenerFunc) {
                        fluid.fail("Unable to look up name " + listener + " as a global function")
                    } else {
                        listener = lisrec.listener = listenerFunc
                    }
                }
                if (lisrec.predicate && !lisrec.predicate(listener, args)) {
                    continue
                }
                var value = fluid.tryCatch(function () {
                    var ret = (wrapper ? wrapper(listener) : listener).apply(null, args);
                    if (preventable && ret === false) {
                        return false
                    }
                    if (unicast) {
                        return ret
                    }
                }, function (e) {
                    fluid.log("FireEvent received exception " + e.message + " e " + e + " firing to listener " + i);
                    throw(e)
                });
                if (value !== undefined) {
                    return value
                }
            }
        }

        return{addListener:function (listener, namespace, predicate, priority) {
            if (!listener) {
                return
            }
            if (unicast) {
                namespace = "unicast"
            }
            if (!namespace) {
                namespace = fluid.event.identifyListener(listener)
            }
            listeners[namespace] = {listener:listener, predicate:predicate, priority:fluid.event.mapPriority(priority, sortedListeners.length)};
            sortedListeners = fluid.event.sortListeners(listeners)
        }, removeListener:function (listener) {
            if (typeof(listener) === 'string') {
                delete listeners[listener]
            } else if (listener.$$guid) {
                delete listeners[listener.$$guid]
            }
            sortedListeners = fluid.event.sortListeners(listeners)
        }, fireToListeners:function (listeners, args, wrapper) {
            return fireToListeners(listeners, args, wrapper)
        }, fire:function () {
            return fireToListeners(sortedListeners, arguments)
        }}
    };
    fluid.event.addListenerToFirer = function (firer, value, namespace) {
        if (fluid.isArrayable(value)) {
            for (var i = 0; i < value.length; ++i) {
                fluid.event.addListenerToFirer(firer, value[i], namespace)
            }
        } else if (typeof(value) === "function" || typeof(value) === "string") {
            firer.addListener(value, namespace)
        } else if (value && typeof(value) === "object") {
            firer.addListener(value.listener, namespace || value.namespace, value.predicate, value.priority)
        }
    };
    fluid.mergeListeners = function (that, events, listeners) {
        fluid.each(listeners, function (value, key) {
            var firer, namespace;
            if (key.charAt(0) === "{") {
                if (!fluid.expandOptions) {
                    fluid.fail("fluid.expandOptions could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + key)
                }
                firer = fluid.expandOptions(key, that)
            } else {
                var keydot = key.indexOf(".");
                if (keydot !== -1) {
                    namespace = key.substring(keydot + 1);
                    key = key.substring(0, keydot)
                }
                if (!events[key]) {
                    fluid.fail("Listener registered for event " + key + " which is not defined for this component");
                    events[key] = fluid.event.getEventFirer()
                }
                firer = events[key]
            }
            fluid.event.addListenerToFirer(firer, value, namespace)
        })
    };
    function initEvents(that, events, pass) {
        fluid.each(events, function (eventSpec, eventKey) {
            var isIoCEvent = eventSpec && (typeof(eventSpec) !== "string" || eventSpec.charAt(0) === "{");
            var event;
            if (isIoCEvent && pass === "IoC") {
                if (!fluid.event.resolveEvent) {
                    fluid.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ", eventSpec)
                } else {
                    event = fluid.event.resolveEvent(that, eventKey, eventSpec)
                }
            } else if (pass === "flat") {
                event = fluid.event.getEventFirer(eventSpec === "unicast", eventSpec === "preventable")
            }
            if (event) {
                that.events[eventKey] = event
            }
        })
    }

    fluid.instantiateFirers = function (that, options) {
        that.events = {};
        initEvents(that, options.events, "flat");
        initEvents(that, options.events, "IoC");
        var listeners = fluid.expandOptions ? fluid.expandOptions(options.listeners, that) : options.listeners;
        fluid.mergeListeners(that, that.events, listeners)
    };
    fluid.mergeListenersPolicy = function (target, source) {
        var togo = target || {};
        fluid.each(source, function (listeners, key) {
            togo[key] = fluid.makeArray(source[key]).concat(fluid.makeArray(listeners))
        });
        return togo
    };
    var defaultsStore = {};
    var resolveGradesImpl = function (gs, gradeNames) {
        gradeNames = fluid.makeArray(gradeNames);
        fluid.each(gradeNames, function (gradeName) {
            var options = fluid.rawDefaults(gradeName) || {};
            gs.gradeHash[gradeName] = true;
            gs.gradeChain.push(gradeName);
            gs.optionsChain.push(options);
            fluid.each(options.gradeNames, function (parent) {
                if (!gs.gradeHash[parent]) {
                    resolveGradesImpl(gs, parent)
                }
            })
        });
        return gs
    };
    fluid.resolveGradeStructure = function (gradeNames) {
        var gradeStruct = {gradeChain:[], gradeHash:{}, optionsChain:[]};
        return resolveGradesImpl(gradeStruct, gradeNames)
    };
    fluid.lifecycleFunctions = {preInitFunction:true, postInitFunction:true, finalInitFunction:true};
    fluid.mergeLifecycleFunction = function (target, source) {
        fluid.event.addListenerToFirer(target, source);
        return target
    };
    fluid.rootMergePolicy = fluid.transform(fluid.lifecycleFunctions, function () {
        return fluid.mergeLifecycleFunction
    });
    fluid.makeLifecycleFirers = function () {
        return fluid.transform(fluid.lifecycleFunctions, function () {
            return fluid.event.getEventFirer()
        })
    };
    fluid.resolveGrade = function (defaults, gradeNames) {
        var mergeArgs = [defaults];
        if (gradeNames) {
            var gradeStruct = fluid.resolveGradeStructure(gradeNames);
            mergeArgs = gradeStruct.optionsChain.reverse().concat(mergeArgs).concat({gradeNames:gradeStruct.gradeChain})
        }
        mergeArgs = [fluid.rootMergePolicy, fluid.makeLifecycleFirers()].concat(mergeArgs);
        var mergedDefaults = fluid.merge.apply(null, mergeArgs);
        return mergedDefaults
    };
    fluid.resolveGradedOptions = function (componentName) {
        var defaults = fluid.rawDefaults(componentName);
        if (!defaults) {
            return defaults
        } else {
            return fluid.resolveGrade(defaults, defaults.gradeNames)
        }
    };
    fluid.rawDefaults = function (componentName, options) {
        if (options === undefined) {
            return defaultsStore[componentName]
        } else {
            defaultsStore[componentName] = options
        }
    };
    fluid.hasGrade = function (options, gradeName) {
        return!options || !options.gradeNames ? false : fluid.contains(options.gradeNames, gradeName)
    };
    fluid.defaults = function () {
        var offset = 0;
        if (typeof arguments[0] === "boolean") {
            offset = 1
        }
        var componentName = (offset === 0 ? "" : "*.global-") + arguments[offset];
        var options = arguments[offset + 1];
        if (options === undefined) {
            return fluid.resolveGradedOptions(componentName)
        } else {
            if (options && options.options) {
                fluid.fail("Probable error in options structure with option named \"options\" - perhaps you meant to write these options at top level in fluid.defaults?")
            }
            fluid.rawDefaults(componentName, options);
            if (fluid.hasGrade(options, "autoInit")) {
                fluid.makeComponent(componentName, fluid.resolveGradedOptions(componentName))
            }
        }
    };
    fluid.makeComponent = function (componentName, options) {
        if (!options.initFunction || !options.gradeNames) {
            fluid.fail("Cannot autoInit component " + componentName + " which does not have an initFunction and gradeName defined")
        }
        var creator = function () {
            return fluid.initComponent(componentName, arguments)
        };
        var existing = fluid.getGlobalValue(componentName);
        if (existing) {
            $.extend(creator, existing)
        }
        fluid.setGlobalValue(componentName, creator)
    };
    fluid.makeComponents = function (components, env) {
        fluid.each(components, function (value, key) {
            var options = {gradeNames:fluid.makeArray(value).concat(["autoInit"])};
            fluid.defaults(key, options)
        })
    };
    fluid.defaults("fluid.littleComponent", {initFunction:"fluid.initLittleComponent", argumentMap:{options:0}});
    fluid.defaults("fluid.eventedComponent", {gradeNames:["fluid.littleComponent"], mergePolicy:{listeners:"fluid.mergeListenersPolicy"}});
    fluid.preInitModelComponent = function (that) {
        that.model = that.options.model || {};
        that.applier = that.options.applier || fluid.makeChangeApplier(that.model, that.options.changeApplierOptions)
    };
    fluid.defaults("fluid.modelComponent", {gradeNames:["fluid.littleComponent"], preInitFunction:{namespace:"preInitModelComponent", listener:"fluid.preInitModelComponent"}, mergePolicy:{model:"preserve", applier:"nomerge"}});
    fluid.defaults("fluid.viewComponent", {gradeNames:["fluid.littleComponent", "fluid.modelComponent", "fluid.eventedComponent"], initFunction:"fluid.initView", argumentMap:{container:0, options:1}});
    fluid.guardCircularity = function (seenIds, source, message1, message2) {
        if (source && source.id) {
            if (!seenIds[source.id]) {
                seenIds[source.id] = source
            } else if (seenIds[source.id] === source) {
                fluid.fail("Circularity in options " + message1 + " - component with typename " + source.typeName + " and id " + source.id + " has already been seen" + message2)
            }
        }
    };
    fluid.mergePolicyIs = function (policy, test) {
        return typeof(policy) === "string" && $.inArray(test, policy.split(/\s*,\s*/)) !== -1
    };
    function mergeImpl(policy, basePath, target, source, thisPolicy, rec) {
        if (typeof(thisPolicy) === "function") {
            thisPolicy.call(null, target, source);
            return target
        }
        if (fluid.mergePolicyIs(thisPolicy, "replace")) {
            fluid.clear(target)
        }
        fluid.guardCircularity(rec.seenIds, source, "merging", " when evaluating path " + basePath + " - please protect components from merging using the \"nomerge\" merge policy");
        for (var name in source) {
            var path = (basePath ? basePath + "." : "") + name;
            var newPolicy = policy && typeof(policy) !== "string" ? policy[path] : policy;
            var thisTarget = target[name];
            var thisSource = source[name];
            var primitiveTarget = fluid.isPrimitive(thisTarget);
            if (thisSource !== undefined) {
                if (thisSource !== null && typeof(thisSource) === "object" && !fluid.isDOMNode(thisSource) && !thisSource.jquery && thisSource !== fluid.VALUE && !fluid.mergePolicyIs(newPolicy, "preserve") && !fluid.mergePolicyIs(newPolicy, "nomerge") && !fluid.mergePolicyIs(newPolicy, "noexpand")) {
                    if (primitiveTarget) {
                        target[name] = thisTarget = fluid.freshContainer(thisSource)
                    }
                    mergeImpl(policy, path, thisTarget, thisSource, newPolicy, rec)
                } else {
                    if (typeof(newPolicy) === "function") {
                        target[name] = newPolicy.call(null, thisTarget, thisSource, name)
                    } else if (!fluid.isValue(thisTarget) || !fluid.mergePolicyIs(newPolicy, "reverse")) {
                        target[name] = fluid.isValue(thisTarget) && fluid.mergePolicyIs(newPolicy, "preserve") ? fluid.model.mergeModel(thisTarget, thisSource) : thisSource
                    }
                }
            }
        }
        return target
    }

    fluid.merge = function (policy, target) {
        var path = "";
        for (var i = 2; i < arguments.length; ++i) {
            var source = arguments[i];
            if (source !== null && source !== undefined) {
                mergeImpl(policy, path, target, source, policy ? policy[""] : null, {seenIds:{}})
            }
        }
        if (policy && typeof(policy) !== "string") {
            for (var key in policy) {
                var elrh = policy[key];
                if (typeof(elrh) === "string" && elrh !== "replace" && elrh !== "preserve") {
                    var oldValue = fluid.get(target, key);
                    if (oldValue === null || oldValue === undefined) {
                        var value = fluid.get(target, elrh);
                        fluid.set(target, key, value)
                    }
                }
            }
        }
        return target
    };
    fluid.transformOptions = function (mergeArgs, transRec) {
        fluid.expect("Options transformation record", ["transformer", "config"], transRec);
        var transFunc = fluid.getGlobalValue(transRec.transformer);
        var togo = fluid.transform(mergeArgs, function (value, key) {
            return key === 0 ? value : transFunc.call(null, value, transRec.config)
        });
        return togo
    };
    fluid.lastTransformationRecord = function (extraArgs) {
        for (var i = extraArgs.length - 1; i >= 0; --i) {
            if (extraArgs[i] && extraArgs[i].transformOptions) {
                return extraArgs[i].transformOptions
            }
        }
    };
    fluid.mergeComponentOptions = function (that, componentName, userOptions, localOptions) {
        var defaults = fluid.defaults(componentName);
        var mergePolicy = $.extend({}, fluid.rootMergePolicy, defaults ? defaults.mergePolicy : {});
        var defaultGrades = defaults && defaults.gradeNames;
        var mergeArgs;
        if (!defaultGrades) {
            defaults = fluid.censorKeys(defaults, fluid.keys(fluid.lifecycleFunctions));
            mergeArgs = [mergePolicy, localOptions]
        } else {
            mergeArgs = [mergePolicy]
        }
        var extraArgs;
        if (fluid.expandComponentOptions) {
            extraArgs = fluid.expandComponentOptions(defaults, userOptions, that)
        } else {
            extraArgs = [defaults, userOptions]
        }
        var transRec = fluid.lastTransformationRecord(extraArgs);
        if (transRec) {
            extraArgs = fluid.transformOptions(extraArgs, transRec)
        }
        mergeArgs = mergeArgs.concat(extraArgs);
        that.options = fluid.merge.apply(null, mergeArgs)
    };
    fluid.COMPONENT_OPTIONS = {type:"fluid.marker", value:"COMPONENT_OPTIONS"};
    fluid.emptySubcomponent = function (options) {
        var that = {};
        options = $.makeArray(options);
        var empty = function () {
        };
        for (var i = 0; i < options.length; ++i) {
            that[options[i]] = empty
        }
        return that
    };
    fluid.computeNickName = function (typeName) {
        var segs = fluid.model.parseEL(typeName);
        return segs[segs.length - 1]
    };
    fluid.typeTag = function (name) {
        return name ? {typeName:name, id:fluid.allocateGuid()} : null
    };
    fluid.typeFount = function (options) {
        var that = fluid.initLittleComponent("fluid.typeFount", options);
        return fluid.typeTag(that.options.targetTypeName)
    };
    fluid.initLittleComponent = function (name, options, localOptions) {
        var that = fluid.typeTag(name);
        that.nickName = options && options.nickName ? options.nickName : fluid.computeNickName(that.typeName);
        localOptions = localOptions || {gradeNames:"fluid.littleComponent"};
        localOptions = fluid.resolveGrade({}, localOptions.gradeNames);
        fluid.mergeComponentOptions(that, name, options, localOptions);
        that.options.preInitFunction.fire(that);
        if (fluid.hasGrade(that.options, "fluid.eventedComponent")) {
            fluid.instantiateFirers(that, that.options)
        }
        if (!fluid.hasGrade(that.options, "autoInit")) {
            fluid.clearLifecycleFunctions(that.options)
        }
        return that
    };
    fluid.clearLifecycleFunctions = function (options) {
        fluid.each(fluid.lifecycleFunctions, function (value, key) {
            delete options[key]
        });
        delete options.initFunction
    };
    fluid.diagnoseFailedView = function (componentName, that, options, args) {
        if (!that && fluid.hasGrade(options, "fluid.viewComponent")) {
            var container = fluid.wrap(args[1]);
            var message1 = "Instantiation of autoInit component with type " + componentName + " failed, since "
            if (container.length === 0) {
                fluid.fail(message1 + "selector \"", args[1], "\" did not match any markup in the document")
            } else {
                fluid.fail(message1 + " component creator function did not return a value")
            }
        }
    };
    fluid.initComponent = function (componentName, initArgs) {
        var options = fluid.defaults(componentName);
        if (!options.gradeNames) {
            fluid.fail("Cannot initialise component " + componentName + " which has no gradeName registered")
        }
        var args = [componentName].concat(fluid.makeArray(initArgs));
        var that = fluid.invokeGlobalFunction(options.initFunction, args);
        fluid.diagnoseFailedView(componentName, that, options, args);
        that.options.postInitFunction.fire(that);
        if (fluid.initDependents) {
            fluid.initDependents(that)
        }
        that.options.finalInitFunction.fire(that);
        fluid.clearLifecycleFunctions(that.options);
        return that.options.returnedPath ? fluid.get(that, that.options.returnedPath) : that
    };
    fluid.initSubcomponentImpl = function (that, entry, args) {
        var togo;
        if (typeof(entry) !== "function") {
            var entryType = typeof(entry) === "string" ? entry : entry.type;
            var globDef = fluid.defaults(true, entryType);
            fluid.merge("reverse", that.options, globDef);
            togo = entryType === "fluid.emptySubcomponent" ? fluid.emptySubcomponent(entry.options) : fluid.invokeGlobalFunction(entryType, args)
        } else {
            togo = entry.apply(null, args)
        }
        var returnedOptions = togo ? togo.returnedOptions : null;
        if (returnedOptions) {
            fluid.merge(that.options.mergePolicy, that.options, returnedOptions);
            if (returnedOptions.listeners) {
                fluid.mergeListeners(that, that.events, returnedOptions.listeners)
            }
        }
        return togo
    };
    fluid.initSubcomponents = function (that, className, args) {
        var entry = that.options[className];
        if (!entry) {
            return
        }
        var entries = $.makeArray(entry);
        var optindex = -1;
        var togo = [];
        args = $.makeArray(args);
        for (var i = 0; i < args.length; ++i) {
            if (args[i] === fluid.COMPONENT_OPTIONS) {
                optindex = i
            }
        }
        for (i = 0; i < entries.length; ++i) {
            entry = entries[i];
            if (optindex !== -1) {
                args[optindex] = entry.options
            }
            togo[i] = fluid.initSubcomponentImpl(that, entry, args)
        }
        return togo
    };
    fluid.initSubcomponent = function (that, className, args) {
        return fluid.initSubcomponents(that, className, args)[0]
    };
    fluid.checkTryCatchParameter = function () {
        var location = window.location || {search:"", protocol:"file:"};
        var GETParams = location.search.slice(1).split('&');
        return fluid.contains(GETParams, "notrycatch")
    };
    fluid.notrycatch = fluid.checkTryCatchParameter();
    fluid.container = function (containerSpec, fallible) {
        var container = fluid.wrap(containerSpec);
        if (fallible && (!container || container.length === 0)) {
            return null
        }
        if (!container || !container.jquery || container.length !== 1) {
            if (typeof(containerSpec) !== "string") {
                containerSpec = container.selector
            }
            var count = container.length !== undefined ? container.length : 0;
            fluid.fail((count > 1 ? "More than one (" + count + ") container elements were" : "No container element was") + " found for selector " + containerSpec)
        }
        if (!fluid.isDOMNode(container[0])) {
            fluid.fail("fluid.container was supplied a non-jQueryable element")
        }
        return container
    };
    fluid.createDomBinder = function (container, selectors) {
        var cache = {}, that = {};

        function cacheKey(name, thisContainer) {
            return fluid.allocateSimpleId(thisContainer) + "-" + name
        }

        function record(name, thisContainer, result) {
            cache[cacheKey(name, thisContainer)] = result
        }

        that.locate = function (name, localContainer) {
            var selector, thisContainer, togo;
            selector = selectors[name];
            thisContainer = localContainer ? localContainer : container;
            if (!thisContainer) {
                fluid.fail("DOM binder invoked for selector " + name + " without container")
            }
            if (!selector) {
                return thisContainer
            }
            if (typeof(selector) === "function") {
                togo = $(selector.call(null, fluid.unwrap(thisContainer)))
            } else {
                togo = $(selector, thisContainer)
            }
            if (togo.get(0) === document) {
                togo = []
            }
            if (!togo.selector) {
                togo.selector = selector;
                togo.context = thisContainer
            }
            togo.selectorName = name;
            record(name, thisContainer, togo);
            return togo
        };
        that.fastLocate = function (name, localContainer) {
            var thisContainer = localContainer ? localContainer : container;
            var key = cacheKey(name, thisContainer);
            var togo = cache[key];
            return togo ? togo : that.locate(name, localContainer)
        };
        that.clear = function () {
            cache = {}
        };
        that.refresh = function (names, localContainer) {
            var thisContainer = localContainer ? localContainer : container;
            if (typeof names === "string") {
                names = [names]
            }
            if (thisContainer.length === undefined) {
                thisContainer = [thisContainer]
            }
            for (var i = 0; i < names.length; ++i) {
                for (var j = 0; j < thisContainer.length; ++j) {
                    that.locate(names[i], thisContainer[j])
                }
            }
        };
        that.resolvePathSegment = that.locate;
        return that
    };
    fluid.expectFilledSelector = function (result, message) {
        if (result && result.length === 0 && result.jquery) {
            fluid.fail(message + ": selector \"" + result.selector + "\" with name " + result.selectorName + " returned no results in context " + fluid.dumpEl(result.context))
        }
    };
    fluid.initView = function (componentName, container, userOptions, localOptions) {
        fluid.expectFilledSelector(container, "Error instantiating component with name \"" + componentName);
        container = fluid.container(container, true);
        if (!container) {
            return null
        }
        var that = fluid.initLittleComponent(componentName, userOptions, localOptions || {gradeNames:["fluid.viewComponent"]});
        that.container = container;
        fluid.initDomBinder(that);
        return that
    };
    fluid.initDomBinder = function (that) {
        that.dom = fluid.createDomBinder(that.container, that.options.selectors);
        that.locate = that.dom.locate
    };
    fluid.findAncestor = function (element, test) {
        element = fluid.unwrap(element);
        while (element) {
            if (test(element)) {
                return element
            }
            element = element.parentNode
        }
    };
    fluid.jById = function (id, dokkument) {
        dokkument = dokkument && dokkument.nodeType === 9 ? dokkument : document;
        var element = fluid.byId(id, dokkument);
        var togo = element ? $(element) : [];
        togo.selector = "#" + id;
        togo.context = dokkument;
        return togo
    };
    fluid.byId = function (id, dokkument) {
        dokkument = dokkument && dokkument.nodeType === 9 ? dokkument : document;
        var el = dokkument.getElementById(id);
        if (el) {
            if (el.id !== id) {
                fluid.fail("Problem in document structure - picked up element " + fluid.dumpEl(el) + " for id " + id + " without this id - most likely the element has a name which conflicts with this id")
            }
            return el
        } else {
            return null
        }
    };
    fluid.getId = function (element) {
        return fluid.unwrap(element).id
    };
    fluid.allocateSimpleId = function (element) {
        var simpleId = "fluid-id-" + fluid.allocateGuid();
        if (!element) {
            return simpleId
        }
        element = fluid.unwrap(element);
        if (!element.id) {
            element.id = simpleId
        }
        return element.id
    };
    fluid.stringToRegExp = function (str, flags) {
        return new RegExp(str.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), flags)
    };
    fluid.stringTemplate = function (template, values) {
        var newString = template;
        for (var key in values) {
            var re = fluid.stringToRegExp("%" + key, "g");
            newString = newString.replace(re, values[key])
        }
        return newString
    };
    fluid.messageResolver = function (options) {
        var that = fluid.initLittleComponent("fluid.messageResolver", options);
        that.messageBase = that.options.parseFunc(that.options.messageBase);
        that.lookup = function (messagecodes) {
            var resolved = fluid.messageResolver.resolveOne(that.messageBase, messagecodes);
            if (resolved === undefined) {
                return fluid.find(that.options.parents, function (parent) {
                    return parent.lookup(messagecodes)
                })
            } else {
                return{template:resolved, resolveFunc:that.options.resolveFunc}
            }
        };
        that.resolve = function (messagecodes, args) {
            if (!messagecodes) {
                return"[No messagecodes provided]"
            }
            messagecodes = fluid.makeArray(messagecodes);
            var looked = that.lookup(messagecodes);
            return looked ? looked.resolveFunc(looked.template, args) : "[Message string for key " + messagecodes[0] + " not found]"
        };
        return that
    };
    fluid.defaults("fluid.messageResolver", {mergePolicy:{messageBase:"preserve"}, resolveFunc:fluid.stringTemplate, parseFunc:fluid.identity, messageBase:{}, parents:[]});
    fluid.messageResolver.resolveOne = function (messageBase, messagecodes) {
        for (var i = 0; i < messagecodes.length; ++i) {
            var code = messagecodes[i];
            var message = messageBase[code];
            if (message !== undefined) {
                return message
            }
        }
    };
    fluid.messageLocator = function (messageBase, resolveFunc) {
        var resolver = fluid.messageResolver({messageBase:messageBase, resolveFunc:resolveFunc});
        return function (messagecodes, args) {
            return resolver.resolve(messagecodes, args)
        }
    }
})(jQuery, fluid_1_4);
(function ($, fluid) {
    fluid.dom = fluid.dom || {};
    var getNextNode = function (iterator) {
        if (iterator.node.firstChild) {
            iterator.node = iterator.node.firstChild;
            iterator.depth += 1;
            return iterator
        }
        while (iterator.node) {
            if (iterator.node.nextSibling) {
                iterator.node = iterator.node.nextSibling;
                return iterator
            }
            iterator.node = iterator.node.parentNode;
            iterator.depth -= 1
        }
        return iterator
    };
    fluid.dom.iterateDom = function (node, acceptor, allNodes) {
        var currentNode = {node:node, depth:0};
        var prevNode = node;
        var condition;
        while (currentNode.node !== null && currentNode.depth >= 0 && currentNode.depth < fluid.dom.iterateDom.DOM_BAIL_DEPTH) {
            condition = null;
            if (currentNode.node.nodeType === 1 || allNodes) {
                condition = acceptor(currentNode.node, currentNode.depth)
            }
            if (condition) {
                if (condition === "delete") {
                    currentNode.node.parentNode.removeChild(currentNode.node);
                    currentNode.node = prevNode
                } else if (condition === "stop") {
                    return currentNode.node
                }
            }
            prevNode = currentNode.node;
            currentNode = getNextNode(currentNode)
        }
    };
    fluid.dom.iterateDom.DOM_BAIL_DEPTH = 256;
    fluid.dom.isContainer = function (container, containee) {
        for (; containee; containee = containee.parentNode) {
            if (container === containee) {
                return true
            }
        }
        return false
    };
    fluid.dom.getElementText = function (element) {
        var nodes = element.childNodes;
        var text = "";
        for (var i = 0; i < nodes.length; ++i) {
            var child = nodes[i];
            if (child.nodeType === 3) {
                text = text + child.nodeValue
            }
        }
        return text
    }
})(jQuery, fluid_1_4);
(function ($, fluid) {
    fluid.BINDING_ROOT_KEY = "fluid-binding-root";
    fluid.findData = function (elem, name) {
        while (elem) {
            var data = $.data(elem, name);
            if (data) {
                return data
            }
            elem = elem.parentNode
        }
    };
    fluid.bindFossils = function (node, data, fossils) {
        $.data(node, fluid.BINDING_ROOT_KEY, {data:data, fossils:fossils})
    };
    fluid.boundPathForNode = function (node, fossils) {
        node = fluid.unwrap(node);
        var key = node.name || node.id;
        var record = fossils[key];
        return record ? record.EL : null
    };
    fluid.findForm = function (node) {
        return fluid.findAncestor(node, function (element) {
            return element.nodeName.toLowerCase() === "form"
        })
    };
    fluid.value = function (nodeIn, newValue) {
        var node = fluid.unwrap(nodeIn);
        var multiple = false;
        if (node.nodeType === undefined && node.length > 1) {
            node = node[0];
            multiple = true
        }
        if ("input" !== node.nodeName.toLowerCase() || !/radio|checkbox/.test(node.type)) {
            return newValue === undefined ? $(node).val() : $(node).val(newValue)
        }
        var name = node.name;
        if (name === undefined) {
            fluid.fail("Cannot acquire value from node " + fluid.dumpEl(node) + " which does not have name attribute set")
        }
        var elements;
        if (multiple) {
            elements = nodeIn
        } else {
            elements = document.getElementsByName(name);
            var scope = fluid.findForm(node);
            elements = $.grep(elements, function (element) {
                if (element.name !== name) {
                    return false
                }
                return!scope || fluid.dom.isContainer(scope, element)
            })
        }
        if (newValue !== undefined) {
            if (typeof(newValue) === "boolean") {
                newValue = (newValue ? "true" : "false")
            }
            $.each(elements, function () {
                this.checked = (newValue instanceof Array ? $.inArray(this.value, newValue) !== -1 : newValue === this.value)
            })
        } else {
            var checked = $.map(elements, function (element) {
                return element.checked ? element.value : null
            });
            return node.type === "radio" ? checked[0] : checked
        }
    };
    fluid.applyChange = function (node, newValue, applier) {
        node = fluid.unwrap(node);
        if (newValue === undefined) {
            newValue = fluid.value(node)
        }
        if (node.nodeType === undefined && node.length > 0) {
            node = node[0]
        }
        var root = fluid.findData(node, fluid.BINDING_ROOT_KEY);
        if (!root) {
            fluid.fail("Bound data could not be discovered in any node above " + fluid.dumpEl(node))
        }
        var name = node.name;
        var fossil = root.fossils[name];
        if (!fossil) {
            fluid.fail("No fossil discovered for name " + name + " in fossil record above " + fluid.dumpEl(node))
        }
        if (typeof(fossil.oldvalue) === "boolean") {
            newValue = newValue[0] ? true : false
        }
        var EL = root.fossils[name].EL;
        if (applier) {
            applier.fireChangeRequest({path:EL, value:newValue, source:node.id})
        } else {
            fluid.set(root.data, EL, newValue)
        }
    };
    fluid.pathUtil = {};
    var getPathSegmentImpl = function (accept, path, i) {
        var segment = null;
        if (accept) {
            segment = ""
        }
        var escaped = false;
        var limit = path.length;
        for (; i < limit; ++i) {
            var c = path.charAt(i);
            if (!escaped) {
                if (c === '.') {
                    break
                } else if (c === '\\') {
                    escaped = true
                } else if (segment !== null) {
                    segment += c
                }
            } else {
                escaped = false;
                if (segment !== null) {
                    accept += c
                }
            }
        }
        if (segment !== null) {
            accept[0] = segment
        }
        return i
    };
    var globalAccept = [];
    fluid.pathUtil.getPathSegment = function (path, i) {
        getPathSegmentImpl(globalAccept, path, i);
        return globalAccept[0]
    };
    fluid.pathUtil.getHeadPath = function (path) {
        return fluid.pathUtil.getPathSegment(path, 0)
    };
    fluid.pathUtil.getFromHeadPath = function (path) {
        var firstdot = getPathSegmentImpl(null, path, 0);
        return firstdot === path.length ? null : path.substring(firstdot + 1)
    };
    function lastDotIndex(path) {
        return path.lastIndexOf(".")
    }

    fluid.pathUtil.getToTailPath = function (path) {
        var lastdot = lastDotIndex(path);
        return lastdot === -1 ? null : path.substring(0, lastdot)
    };
    fluid.pathUtil.getTailPath = function (path) {
        var lastdot = lastDotIndex(path);
        return fluid.pathUtil.getPathSegment(path, lastdot + 1)
    };
    var composeSegment = function (prefix, toappend) {
        for (var i = 0; i < toappend.length; ++i) {
            var c = toappend.charAt(i);
            if (c === '.' || c === '\\' || c === '}') {
                prefix += '\\'
            }
            prefix += c
        }
        return prefix
    };
    fluid.pathUtil.composePath = function (prefix, suffix) {
        if (prefix.length !== 0) {
            prefix += '.'
        }
        return composeSegment(prefix, suffix)
    };
    fluid.pathUtil.matchPath = function (spec, path) {
        var togo = "";
        while (true) {
            if (!spec || path === "") {
                break
            }
            if (!path) {
                return null
            }
            var spechead = fluid.pathUtil.getHeadPath(spec);
            var pathhead = fluid.pathUtil.getHeadPath(path);
            if (spechead !== "*" && spechead !== pathhead) {
                return null
            }
            togo = fluid.pathUtil.composePath(togo, pathhead);
            spec = fluid.pathUtil.getFromHeadPath(spec);
            path = fluid.pathUtil.getFromHeadPath(path)
        }
        return togo
    };
    fluid.model.mergeModel = function (target, source, applier) {
        var copySource = fluid.copy(source);
        applier = applier || fluid.makeChangeApplier(source);
        if (!fluid.isPrimitive(target)) {
            applier.fireChangeRequest({type:"ADD", path:"", value:target})
        }
        applier.fireChangeRequest({type:"MERGE", path:"", value:copySource});
        return source
    };
    fluid.model.isNullChange = function (model, request, resolverGetConfig) {
        if (request.type === "ADD") {
            var existing = fluid.get(model, request.path, resolverGetConfig);
            if (existing === request.value) {
                return true
            }
        }
    };
    fluid.model.applyChangeRequest = function (model, request, resolverSetConfig) {
        var pen = fluid.model.getPenultimate(model, request.path, resolverSetConfig || fluid.model.defaultSetConfig);
        if (request.type === "ADD" || request.type === "MERGE") {
            if (request.path === "" || request.type === "MERGE") {
                if (request.type === "ADD") {
                    fluid.clear(pen.root)
                }
                $.extend(true, request.path === "" ? pen.root : pen.root[pen.last], request.value)
            } else {
                pen.root[pen.last] = request.value
            }
        } else if (request.type === "DELETE") {
            if (request.path === "") {
                fluid.clear(pen.root)
            } else {
                delete pen.root[pen.last]
            }
        }
    };
    function bindRequestChange(that) {
        that.requestChange = function (path, value, type) {
            var changeRequest = {path:path, value:value, type:type};
            that.fireChangeRequest(changeRequest)
        }
    }

    fluid.makeChangeApplier = function (model, options) {
        options = options || {};
        var baseEvents = {guards:fluid.event.getEventFirer(false, true), postGuards:fluid.event.getEventFirer(false, true), modelChanged:fluid.event.getEventFirer(false, false)};
        var that = {model:model};

        function makeGuardWrapper(cullUnchanged) {
            if (!cullUnchanged) {
                return null
            }
            var togo = function (guard) {
                return function (model, changeRequest, internalApplier) {
                    var oldRet = guard(model, changeRequest, internalApplier);
                    if (oldRet === false) {
                        return false
                    } else {
                        if (fluid.model.isNullChange(model, changeRequest)) {
                            togo.culled = true;
                            return false
                        }
                    }
                }
            };
            return togo
        }

        function wrapListener(listener, spec) {
            var pathSpec = spec;
            var transactional = false;
            var priority = Number.MAX_VALUE;
            if (typeof(spec) !== "string") {
                pathSpec = spec.path;
                transactional = spec.transactional;
                if (spec.priority !== undefined) {
                    priority = spec.priority
                }
            } else {
                if (pathSpec.charAt(0) === "!") {
                    transactional = true;
                    pathSpec = pathSpec.substring(1)
                }
            }
            return function (changePath, fireSpec, accum) {
                var guid = fluid.event.identifyListener(listener);
                var exist = fireSpec.guids[guid];
                if (!exist) {
                    var match = fluid.pathUtil.matchPath(pathSpec, changePath);
                    if (match !== null) {
                        var record = {changePath:changePath, pathSpec:pathSpec, listener:listener, priority:priority, transactional:transactional};
                        if (accum) {
                            record.accumulate = [accum]
                        }
                        fireSpec.guids[guid] = record;
                        var collection = transactional ? "transListeners" : "listeners";
                        fireSpec[collection].push(record);
                        fireSpec.all.push(record)
                    }
                } else if (accum) {
                    if (!exist.accumulate) {
                        exist.accumulate = []
                    }
                    exist.accumulate.push(accum)
                }
            }
        }

        function fireFromSpec(name, fireSpec, args, category, wrapper) {
            return baseEvents[name].fireToListeners(fireSpec[category], args, wrapper)
        }

        function fireComparator(recA, recB) {
            return recA.priority - recB.priority
        }

        function prepareFireEvent(name, changePath, fireSpec, accum) {
            baseEvents[name].fire(changePath, fireSpec, accum);
            fireSpec.all.sort(fireComparator);
            fireSpec.listeners.sort(fireComparator);
            fireSpec.transListeners.sort(fireComparator)
        }

        function makeFireSpec() {
            return{guids:{}, all:[], listeners:[], transListeners:[]}
        }

        function getFireSpec(name, changePath) {
            var fireSpec = makeFireSpec();
            prepareFireEvent(name, changePath, fireSpec);
            return fireSpec
        }

        function fireEvent(name, changePath, args, wrapper) {
            var fireSpec = getFireSpec(name, changePath);
            return fireFromSpec(name, fireSpec, args, "all", wrapper)
        }

        function adaptListener(that, name) {
            that[name] = {addListener:function (spec, listener, namespace) {
                baseEvents[name].addListener(wrapListener(listener, spec), namespace)
            }, removeListener:function (listener) {
                baseEvents[name].removeListener(listener)
            }}
        }

        adaptListener(that, "guards");
        adaptListener(that, "postGuards");
        adaptListener(that, "modelChanged");
        function preFireChangeRequest(changeRequest) {
            if (!changeRequest.type) {
                changeRequest.type = "ADD"
            }
        }

        var bareApplier = {fireChangeRequest:function (changeRequest) {
            that.fireChangeRequest(changeRequest, true)
        }};
        bindRequestChange(bareApplier);
        that.fireChangeRequest = function (changeRequest, defeatGuards) {
            preFireChangeRequest(changeRequest);
            var guardFireSpec = defeatGuards ? null : getFireSpec("guards", changeRequest.path);
            if (guardFireSpec && guardFireSpec.transListeners.length > 0) {
                var ation = that.initiate();
                ation.fireChangeRequest(changeRequest, guardFireSpec);
                ation.commit()
            } else {
                if (!defeatGuards) {
                    var prevent = fireFromSpec("guards", guardFireSpec, [model, changeRequest, bareApplier], "listeners");
                    if (prevent === false) {
                        return false
                    }
                }
                var oldModel = model;
                if (!options.thin) {
                    oldModel = {};
                    fluid.model.copyModel(oldModel, model)
                }
                fluid.model.applyChangeRequest(model, changeRequest, options.resolverSetConfig);
                fireEvent("modelChanged", changeRequest.path, [model, oldModel, [changeRequest]])
            }
        };
        bindRequestChange(that);
        function fireAgglomerated(eventName, formName, changes, args, accpos) {
            var fireSpec = makeFireSpec();
            for (var i = 0; i < changes.length; ++i) {
                prepareFireEvent(eventName, changes[i].path, fireSpec, changes[i])
            }
            for (var j = 0; j < fireSpec[formName].length; ++j) {
                var spec = fireSpec[formName][j];
                if (accpos) {
                    args[accpos] = spec.accumulate
                }
                var ret = spec.listener.apply(null, args);
                if (ret === false) {
                    return false
                }
            }
        }

        that.initiate = function (newModel) {
            var cancelled = false;
            var changes = [];
            if (options.thin) {
                newModel = model
            } else {
                newModel = newModel || {};
                fluid.model.copyModel(newModel, model)
            }
            var internalApplier = {fireChangeRequest:function (changeRequest) {
                preFireChangeRequest(changeRequest);
                fluid.model.applyChangeRequest(newModel, changeRequest, options.resolverSetConfig);
                changes.push(changeRequest)
            }};
            bindRequestChange(internalApplier);
            var ation = {commit:function () {
                var oldModel;
                if (cancelled) {
                    return false
                }
                var ret = fireAgglomerated("postGuards", "transListeners", changes, [newModel, null, internalApplier], 1);
                if (ret === false) {
                    return false
                }
                if (options.thin) {
                    oldModel = model
                } else {
                    oldModel = {};
                    fluid.model.copyModel(oldModel, model);
                    fluid.clear(model);
                    fluid.model.copyModel(model, newModel)
                }
                fireAgglomerated("modelChanged", "all", changes, [model, oldModel, null], 2)
            }, fireChangeRequest:function (changeRequest) {
                preFireChangeRequest(changeRequest);
                if (options.cullUnchanged && fluid.model.isNullChange(model, changeRequest, options.resolverGetConfig)) {
                    return
                }
                var wrapper = makeGuardWrapper(options.cullUnchanged);
                var prevent = fireEvent("guards", changeRequest.path, [newModel, changeRequest, internalApplier], wrapper);
                if (prevent === false && !(wrapper && wrapper.culled)) {
                    cancelled = true
                }
                if (!cancelled) {
                    if (!(wrapper && wrapper.culled)) {
                        fluid.model.applyChangeRequest(newModel, changeRequest, options.resolverSetConfig);
                        changes.push(changeRequest)
                    }
                }
            }};
            bindRequestChange(ation);
            return ation
        };
        return that
    };
    fluid.makeSuperApplier = function () {
        var subAppliers = [];
        var that = {};
        that.addSubApplier = function (path, subApplier) {
            subAppliers.push({path:path, subApplier:subApplier})
        };
        that.fireChangeRequest = function (request) {
            for (var i = 0; i < subAppliers.length; ++i) {
                var path = subAppliers[i].path;
                if (request.path.indexOf(path) === 0) {
                    var subpath = request.path.substring(path.length + 1);
                    var subRequest = fluid.copy(request);
                    subRequest.path = subpath;
                    subAppliers[i].subApplier.fireChangeRequest(subRequest)
                }
            }
        };
        bindRequestChange(that);
        return that
    };
    fluid.attachModel = function (baseModel, path, model) {
        var segs = fluid.model.parseEL(path);
        for (var i = 0; i < segs.length - 1; ++i) {
            var seg = segs[i];
            var subModel = baseModel[seg];
            if (!subModel) {
                baseModel[seg] = subModel = {}
            }
            baseModel = subModel
        }
        baseModel[segs[segs.length - 1]] = model
    };
    fluid.assembleModel = function (modelSpec) {
        var model = {};
        var superApplier = fluid.makeSuperApplier();
        var togo = {model:model, applier:superApplier};
        for (var path in modelSpec) {
            var rec = modelSpec[path];
            fluid.attachModel(model, path, rec.model);
            if (rec.applier) {
                superApplier.addSubApplier(path, rec.applier)
            }
        }
        return togo
    }
})(jQuery, fluid_1_4);
(function ($, fluid) {
    fluid.renderTimestamp = function (date) {
        var zeropad = function (num, width) {
            if (!width)width = 2;
            var numstr = (num == undefined ? "" : num.toString());
            return"00000".substring(5 - width + numstr.length) + numstr
        }
        return zeropad(date.getHours()) + ":" + zeropad(date.getMinutes()) + ":" + zeropad(date.getSeconds()) + "." + zeropad(date.getMilliseconds(), 3)
    };
    fluid.detectStackStyle = function (e) {
        var style = "other";
        var stackStyle = {offset:0};
        if (e["arguments"]) {
            style = "chrome"
        } else if (typeof window !== "undefined" && window.opera && e.stacktrace) {
            style = "opera10"
        } else if (e.stack) {
            style = "firefox";
            stackStyle.offset = e.stack.indexOf("Trace exception") === -1 ? 1 : 0
        } else if (typeof window !== 'undefined' && window.opera && !('stacktrace'in e)) {
            style = "opera"
        }
        stackStyle.style = style;
        return stackStyle
    };
    fluid.obtainException = function () {
        try {
            throw new Error("Trace exception")
        } catch (e) {
            return e
        }
    };
    var stackStyle = fluid.detectStackStyle(fluid.obtainException());
    fluid.registerNamespace("fluid.exceptionDecoders");
    fluid.decodeStack = function () {
        if (stackStyle.style !== "firefox") {
            return null
        }
        var e = fluid.obtainException();
        return fluid.exceptionDecoders[stackStyle.style](e)
    };
    fluid.exceptionDecoders.firefox = function (e) {
        var lines = e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/gm, '{anonymous}(').split('\n');
        return fluid.transform(lines, function (line) {
            var atind = line.indexOf("@");
            return atind === -1 ? [line] : [line.substring(atind + 1), line.substring(0, atind)]
        })
    };
    fluid.getCallerInfo = function (atDepth) {
        atDepth = (atDepth || 3) - stackStyle.offset;
        var stack = fluid.decodeStack();
        return stack ? stack[atDepth][0] : null
    };
    function generate(c, count) {
        var togo = "";
        for (var i = 0; i < count; ++i) {
            togo += c
        }
        return togo
    }

    function printImpl(obj, small, options) {
        var big = small + options.indentChars;
        if (obj === null) {
            return"null"
        } else if (fluid.isPrimitive(obj)) {
            return JSON.stringify(obj)
        } else {
            var j = [];
            if (fluid.isArrayable(obj)) {
                if (obj.length === 0) {
                    return"[]"
                }
                for (var i = 0; i < obj.length; ++i) {
                    j[i] = printImpl(obj[i], big, options)
                }
                return"[\n" + big + j.join(",\n" + big) + "\n" + small + "]"
            } else {
                var i = 0;
                fluid.each(obj, function (value, key) {
                    j[i++] = JSON.stringify(key) + ": " + printImpl(value, big, options)
                });
                return"{\n" + big + j.join(",\n" + big) + "\n" + small + "}"
            }
        }
    }

    fluid.prettyPrintJSON = function (obj, options) {
        options = $.extend({indent:4}, options);
        options.indentChars = generate(" ", options.indent);
        return printImpl(obj, "", options)
    }
    fluid.dumpEl = function (element) {
        var togo;
        if (!element) {
            return"null"
        }
        if (element.nodeType === 3 || element.nodeType === 8) {
            return"[data: " + element.data + "]"
        }
        if (element.nodeType === 9) {
            return"[document: location " + element.location + "]"
        }
        if (!element.nodeType && fluid.isArrayable(element)) {
            togo = "[";
            for (var i = 0; i < element.length; ++i) {
                togo += fluid.dumpEl(element[i]);
                if (i < element.length - 1) {
                    togo += ", "
                }
            }
            return togo + "]"
        }
        element = $(element);
        togo = element.get(0).tagName;
        if (element.id) {
            togo += "#" + element.id
        }
        if (element.attr("class")) {
            togo += "." + element.attr("class")
        }
        return togo
    }
})(jQuery, fluid_1_4);
(function ($, fluid) {
    var inCreationMarker = "__CURRENTLY_IN_CREATION__";
    fluid.isFireBreak = function (component) {
        return component.options && component.options["fluid.visitComponents.fireBreak"]
    };
    fluid.visitComponentChildren = function (that, visitor, options, up, down) {
        options = options || {};
        for (var name in that) {
            var component = that[name];
            if (!component || !component.typeName || (component.id && options.visited && options.visited[component.id])) {
                continue
            }
            if (options.visited) {
                options.visited[component.id] = true
            }
            if (visitor(component, name, options, up, down)) {
                return true
            }
            if (!fluid.isFireBreak(component) && !options.flat) {
                fluid.visitComponentChildren(component, visitor, options, up, down + 1)
            }
        }
    };
    var visitComponents = function (thatStack, visitor, options) {
        options = options || {visited:{}, flat:true};
        var up = 0;
        for (var i = thatStack.length - 1; i >= 0; --i) {
            var that = thatStack[i];
            if (fluid.isFireBreak(that)) {
                return
            }
            if (that.typeName) {
                options.visited[that.id] = true;
                if (visitor(that, "", options, 0, 0)) {
                    return
                }
            }
            if (fluid.visitComponentChildren(that, visitor, options, up, 1)) {
                return
            }
            ++up
        }
    };

    function makeGingerStrategy(instantiator, that, thatStack) {
        return function (component, thisSeg) {
            var atval = component[thisSeg];
            if (atval === undefined) {
                var parentPath = instantiator.idToPath[component.id];
                atval = instantiator.pathToComponent[fluid.composePath(parentPath, thisSeg)];
                if (atval) {
                    atval[inCreationMarker] = true
                }
            }
            if (atval !== undefined) {
                if (atval[inCreationMarker]) {
                    fluid.fail("Component " + fluid.dumpThat(atval) + " at path \"" + thisSeg + "\" of parent " + fluid.dumpThat(component) + " cannot be used for lookup" + " since it is still in creation. Please reorganise your dependencies so that they no longer contain circular references")
                }
            } else {
                if (fluid.get(component, fluid.path("options", "components", thisSeg, "type"))) {
                    fluid.initDependent(component, thisSeg);
                    atval = component[thisSeg]
                }
            }
            return atval
        }
    }

    fluid.dumpThat = function (that, instantiator) {
        return"{ typeName: \"" + that.typeName + "\" id: " + that.id + "}"
    };
    fluid.dumpThatStack = function (thatStack, instantiator) {
        var togo = fluid.transform(thatStack, function (that) {
            var path = instantiator.idToPath[that.id];
            return fluid.dumpThat(that) + (path ? (" - path: " + path) : "")
        });
        return togo.join("\n")
    };
    fluid.describeActivity = function () {
        return fluid.threadLocal().activityStack || []
    };
    fluid.pushActivity = function (func, message) {
        if (!message) {
            return func()
        }
        var root = fluid.threadLocal();
        if (!root.activityStack) {
            root.activityStack = []
        }
        var frames = fluid.makeArray(message);
        frames.push("\n");
        frames.unshift("\n");
        root.activityStack = frames.concat(root.activityStack);
        return fluid.tryCatch(func, null, function () {
            root.activityStack = root.activityStack.slice(frames.length)
        })
    };
    fluid.wrapActivity = function (func, messageSpec) {
        return function () {
            var args = fluid.makeArray(arguments);
            var message = fluid.transform(fluid.makeArray(messageSpec), function (specEl) {
                if (specEl.indexOf("arguments.") === 0) {
                    var el = specEl.substring("arguments.".length);
                    return fluid.get(args, el)
                } else {
                    return specEl
                }
            });
            return fluid.pushActivity(function () {
                return func.apply(null, args)
            }, message)
        }
    };
    var localRecordExpected = /arguments|options|container/;

    function makeStackFetcher(instantiator, parentThat, localRecord, expandOptions) {
        expandOptions = expandOptions || {};
        var thatStack = instantiator.getFullStack(parentThat);
        var fetchStrategies = [fluid.model.funcResolverStrategy, makeGingerStrategy(instantiator, parentThat, thatStack)];
        var fetcher = function (parsed) {
            var context = parsed.context;
            if (localRecord && localRecordExpected.test(context)) {
                var fetched = fluid.get(localRecord[context], parsed.path);
                return(context === "arguments" || expandOptions.direct) ? fetched : {marker:context === "options" ? fluid.EXPAND : fluid.EXPAND_NOW, value:fetched}
            }
            var foundComponent;
            visitComponents(thatStack, function (component, name, options, up, down) {
                if (context === name || context === component.typeName || context === component.nickName) {
                    foundComponent = component;
                    if (down > 1) {
                        fluid.log("***WARNING: value resolution for context " + context + " found at depth " + down + ": this may not be supported in future")
                    }
                    return true
                }
                if (fluid.get(component, fluid.path("options", "components", context, "type")) && !component[context]) {
                    foundComponent = fluid.get(component, context, {strategies:fetchStrategies});
                    return true
                }
            });
            if (!foundComponent && parsed.path !== "") {
                var ref = fluid.renderContextReference(parsed);
                fluid.log("Failed to resolve reference " + ref + ": thatStack contains\n" + fluid.dumpThatStack(thatStack, instantiator));
                fluid.fail("Failed to resolve reference " + ref + " - could not match context with name " + context + " from component root of type " + thatStack[0].typeName, "\ninstantiator contents: ", instantiator)
            }
            return fluid.get(foundComponent, parsed.path, fetchStrategies)
        };
        return fetcher
    }

    function makeStackResolverOptions(instantiator, parentThat, localRecord, expandOptions) {
        return $.extend({}, fluid.defaults("fluid.resolveEnvironment"), {fetcher:makeStackFetcher(instantiator, parentThat, localRecord, expandOptions)})
    }

    fluid.instantiator = function (freeInstantiator) {
        var preThat = {options:{"fluid.visitComponents.fireBreak":true}, idToPath:{}, pathToComponent:{}, stackCount:0, nickName:"instantiator"};
        var that = fluid.typeTag("fluid.instantiator");
        that = $.extend(that, preThat);
        that.stack = function (count) {
            return that.stackCount += count
        };
        that.getThatStack = function (component) {
            var path = that.idToPath[component.id] || "";
            var parsed = fluid.model.parseEL(path);
            var togo = fluid.transform(parsed, function (value, i) {
                var parentPath = fluid.model.composeSegments.apply(null, parsed.slice(0, i + 1));
                return that.pathToComponent[parentPath]
            });
            var root = that.pathToComponent[""];
            if (root) {
                togo.unshift(root)
            }
            return togo
        };
        that.getEnvironmentalStack = function () {
            var togo = [fluid.staticEnvironment];
            if (!freeInstantiator) {
                togo.push(fluid.threadLocal())
            }
            return togo
        };
        that.getFullStack = function (component) {
            var thatStack = component ? that.getThatStack(component) : [];
            return that.getEnvironmentalStack().concat(thatStack)
        };
        function recordComponent(component, path) {
            that.idToPath[component.id] = path;
            if (that.pathToComponent[path]) {
                fluid.fail("Error during instantiation - path " + path + " which has just created component " + fluid.dumpThat(component) + " has already been used for component " + fluid.dumpThat(that.pathToComponent[path]) + " - this is a circular instantiation or other oversight." + " Please clear the component using instantiator.clearComponent() before reusing the path.")
            }
            that.pathToComponent[path] = component
        }

        that.recordRoot = function (component) {
            if (component && component.id && !that.pathToComponent[""]) {
                recordComponent(component, "")
            }
        };
        that.pushUpcomingInstantiation = function (parent, name) {
            that.expectedParent = parent;
            that.expectedName = name
        };
        that.recordComponent = function (component) {
            if (that.expectedName) {
                that.recordKnownComponent(that.expectedParent, component, that.expectedName);
                delete that.expectedName;
                delete that.expectedParent
            } else {
                that.recordRoot(component)
            }
        };
        that.clearComponent = function (component, name, child, options, noModTree) {
            options = options || {visited:{}, flat:true};
            child = child || component[name];
            fluid.visitComponentChildren(child, function (gchild, gchildname) {
                that.clearComponent(child, gchildname, null, options, noModTree)
            }, options);
            var path = that.idToPath[child.id];
            delete that.idToPath[child.id];
            delete that.pathToComponent[path];
            if (!noModTree) {
                delete component[name]
            }
        };
        that.recordKnownComponent = function (parent, component, name) {
            var parentPath = that.idToPath[parent.id] || "";
            var path = fluid.model.composePath(parentPath, name);
            recordComponent(component, path)
        };
        return that
    };
    fluid.freeInstantiator = fluid.instantiator(true);
    fluid.argMapToDemands = function (argMap) {
        var togo = [];
        fluid.each(argMap, function (value, key) {
            togo[value] = "{" + key + "}"
        });
        return togo
    };
    fluid.makePassArgsSpec = function (initArgs) {
        return fluid.transform(initArgs, function (arg, index) {
            return"{arguments}." + index
        })
    };
    function mergeToMergeAll(options) {
        if (options && options.mergeOptions) {
            options.mergeAllOptions = ["{options}"].concat(fluid.makeArray(options.mergeOptions))
        }
    }

    function upgradeMergeOptions(demandspec) {
        mergeToMergeAll(demandspec);
        if (demandspec.mergeAllOptions) {
            if (demandspec.options) {
                fluid.fail("demandspec ", demandspec, " is invalid - cannot specify literal options together with mergeOptions or mergeAllOptions")
            }
            demandspec.options = {mergeAllOptions:demandspec.mergeAllOptions}
        }
        if (demandspec.options) {
            delete demandspec.options.mergeOptions
        }
    }

    fluid.embodyDemands = function (instantiator, parentThat, demandspec, initArgs, options) {
        options = options || {};
        upgradeMergeOptions(demandspec);
        var oldOptions = fluid.get(options, "componentRecord.options");
        options.componentRecord = $.extend(true, {}, options.componentRecord, fluid.censorKeys(demandspec, ["args", "funcName", "registeredFrom"]));
        var mergeAllZero = fluid.get(options, "componentRecord.options.mergeAllOptions.0");
        if (mergeAllZero === "{options}") {
            fluid.set(options, "componentRecord.options.mergeAllOptions.0", oldOptions)
        }
        var demands = $.makeArray(demandspec.args);
        var upDefaults = fluid.defaults(demandspec.funcName);
        var argMap = upDefaults ? upDefaults.argumentMap : null;
        var inferMap = false;
        if (!argMap && (upDefaults || (options && options.componentRecord)) && !options.passArgs) {
            inferMap = true;
            if (demands.length < 2) {
                argMap = fluid.rawDefaults("fluid.littleComponent").argumentMap
            } else {
                argMap = {options:demands.length - 1}
            }
        }
        options = options || {};
        if (demands.length === 0) {
            if (options.componentRecord && argMap) {
                demands = fluid.argMapToDemands(argMap)
            } else if (options.passArgs) {
                demands = fluid.makePassArgsSpec(initArgs)
            }
        }
        var localRecord = $.extend({"arguments":initArgs}, fluid.censorKeys(options.componentRecord, ["type"]));
        fluid.each(argMap, function (index, name) {
            if (initArgs.length > 0) {
                localRecord[name] = localRecord["arguments"][index]
            }
            if (demandspec[name] !== undefined && localRecord[name] === undefined) {
                localRecord[name] = demandspec[name]
            }
        });
        mergeToMergeAll(localRecord.options);
        mergeToMergeAll(argMap && demands[argMap.options]);
        var upstreamLocalRecord = $.extend({}, localRecord);
        if (options.componentRecord.options !== undefined) {
            upstreamLocalRecord.options = options.componentRecord.options
        }
        var expandOptions = makeStackResolverOptions(instantiator, parentThat, localRecord);
        var args = [];
        if (demands) {
            for (var i = 0; i < demands.length; ++i) {
                var arg = demands[i];
                if (fluid.isMarker(arg) && arg.value === fluid.COMPONENT_OPTIONS.value) {
                    arg = "{options}";
                    if (inferMap) {
                        argMap = {options:i}
                    }
                }
                if (typeof(arg) === "string") {
                    if (arg.charAt(0) === "@") {
                        var argpos = arg.substring(1);
                        arg = "{arguments}." + argpos
                    }
                }
                if (!argMap || argMap.options !== i) {
                    args[i] = fluid.expander.expandLight(arg, expandOptions)
                } else {
                    if (arg && typeof(arg) === "object" && !arg.targetTypeName) {
                        arg.targetTypeName = demandspec.funcName
                    }
                    args[i] = {marker:fluid.EXPAND, value:fluid.copy(arg), localRecord:upstreamLocalRecord}
                }
                if (args[i] && fluid.isMarker(args[i].marker, fluid.EXPAND_NOW)) {
                    args[i] = fluid.expander.expandLight(args[i].value, expandOptions)
                }
            }
        } else {
            args = initArgs ? initArgs : []
        }
        var togo = {args:args, funcName:demandspec.funcName};
        return togo
    };
    var aliasTable = {};
    fluid.alias = function (demandingName, aliasName) {
        if (aliasName) {
            aliasTable[demandingName] = aliasName
        } else {
            return aliasTable[demandingName]
        }
    };
    var dependentStore = {};

    function searchDemands(demandingName, contextNames) {
        var exist = dependentStore[demandingName] || [];
        outer:for (var i = 0; i < exist.length; ++i) {
            var rec = exist[i];
            for (var j = 0; j < contextNames.length; ++j) {
                if (rec.contexts[j] !== contextNames[j]) {
                    continue outer
                }
            }
            return rec.spec
        }
    }

    fluid.demands = function (demandingName, contextName, spec) {
        var contextNames = $.makeArray(contextName).sort();
        if (!spec) {
            return searchDemands(demandingName, contextNames)
        } else if (spec.length) {
            spec = {args:spec}
        }
        if (fluid.getCallerInfo) {
            var callerInfo = fluid.getCallerInfo(5);
            if (callerInfo) {
                spec.registeredFrom = callerInfo
            }
        }
        var exist = dependentStore[demandingName];
        if (!exist) {
            exist = [];
            dependentStore[demandingName] = exist
        }
        exist.push({contexts:contextNames, spec:spec})
    };
    fluid.compareDemands = function (speca, specb) {
        var p1 = speca.uncess - specb.uncess;
        return p1 === 0 ? specb.intersect - speca.intersect : p1
    };
    fluid.isDemandLogging = function (demandingNames) {
        return fluid.isLogging() && demandingNames[0] !== "fluid.threadLocal"
    };
    fluid.locateAllDemands = function (instantiator, parentThat, demandingNames) {
        var demandLogging = fluid.isDemandLogging(demandingNames);
        if (demandLogging) {
            fluid.log("Resolving demands for function names ", demandingNames, " in context of " + (parentThat ? "component " + parentThat.typeName : "no component"))
        }
        var contextNames = {};
        var visited = [];
        var thatStack = instantiator.getFullStack(parentThat);
        visitComponents(thatStack, function (component, xname, options, up, down) {
            contextNames[component.typeName] = true;
            visited.push(component)
        });
        if (demandLogging) {
            fluid.log("Components in scope for resolution:\n" + fluid.dumpThatStack(visited, instantiator))
        }
        var matches = [];
        for (var i = 0; i < demandingNames.length; ++i) {
            var rec = dependentStore[demandingNames[i]] || [];
            for (var j = 0; j < rec.length; ++j) {
                var spec = rec[j];
                var record = {spec:spec, intersect:0, uncess:0};
                for (var k = 0; k < spec.contexts.length; ++k) {
                    record[contextNames[spec.contexts[k]] ? "intersect" : "uncess"] += 2
                }
                if (spec.contexts.length === 0) {
                    record.intersect++
                }
                matches.push(record)
            }
        }
        matches.sort(fluid.compareDemands);
        return matches
    };
    fluid.locateDemands = function (instantiator, parentThat, demandingNames) {
        var matches = fluid.locateAllDemands(instantiator, parentThat, demandingNames);
        var demandspec = matches.length === 0 || matches[0].intersect === 0 ? null : matches[0].spec.spec;
        if (fluid.isDemandLogging(demandingNames)) {
            if (demandspec) {
                fluid.log("Located " + matches.length + " potential match" + (matches.length === 1 ? "" : "es") + ", selected best match with " + matches[0].intersect + " matched context names: ", demandspec)
            } else {
                fluid.log("No matches found for demands, using direct implementation")
            }
        }
        return demandspec
    };
    fluid.determineDemands = function (instantiator, parentThat, funcNames) {
        funcNames = $.makeArray(funcNames);
        var newFuncName = funcNames[0];
        var demandspec = fluid.locateDemands(instantiator, parentThat, funcNames) || {};
        if (demandspec.funcName) {
            newFuncName = demandspec.funcName
        }
        var aliasTo = fluid.alias(newFuncName);
        if (aliasTo) {
            newFuncName = aliasTo;
            fluid.log("Following redirect from function name " + newFuncName + " to " + aliasTo);
            var demandspec2 = fluid.locateDemands(instantiator, parentThat, [aliasTo]);
            if (demandspec2) {
                fluid.each(demandspec2, function (value, key) {
                    if (localRecordExpected.test(key)) {
                        fluid.fail("Error in demands block ", demandspec2, " - content with key \"" + key + "\" is not supported since this demands block was resolved via an alias from \"" + newFuncName + "\"")
                    }
                });
                if (demandspec2.funcName) {
                    newFuncName = demandspec2.funcName;
                    fluid.log("Followed final inner demands to function name \"" + newFuncName + "\"")
                }
            }
        }
        return fluid.merge(null, {funcName:newFuncName, args:fluid.makeArray(demandspec.args)}, fluid.censorKeys(demandspec, ["funcName", "args"]))
    };
    fluid.resolveDemands = function (instantiator, parentThat, funcNames, initArgs, options) {
        var demandspec = fluid.determineDemands(instantiator, parentThat, funcNames);
        return fluid.embodyDemands(instantiator, parentThat, demandspec, initArgs, options)
    };
    fluid.invoke = function (functionName, args, that, environment) {
        args = fluid.makeArray(args);
        return fluid.withInstantiator(that, function (instantiator) {
            var invokeSpec = fluid.resolveDemands(instantiator, that, functionName, args, {passArgs:true});
            return fluid.invokeGlobalFunction(invokeSpec.funcName, invokeSpec.args, environment)
        })
    };
    fluid.invoke = fluid.wrapActivity(fluid.invoke, ["    while invoking function with name \"", "arguments.0", "\" from component", "arguments.2"]);
    fluid.makeFreeInvoker = function (functionName, environment) {
        var demandSpec = fluid.determineDemands(fluid.freeInstantiator, null, functionName);
        return function () {
            var invokeSpec = fluid.embodyDemands(fluid.freeInstantiator, null, demandSpec, arguments, {passArgs:true});
            return fluid.invokeGlobalFunction(invokeSpec.funcName, invokeSpec.args, environment)
        }
    };
    fluid.makeInvoker = function (instantiator, that, demandspec, functionName, environment) {
        demandspec = demandspec || fluid.determineDemands(instantiator, that, functionName);
        return function () {
            var args = arguments;
            return fluid.pushActivity(function () {
                var invokeSpec = fluid.embodyDemands(instantiator, that, demandspec, args, {passArgs:true});
                return fluid.invokeGlobalFunction(invokeSpec.funcName, invokeSpec.args, environment)
            }, ["    while invoking invoker with name " + functionName + " on component", that])
        }
    };
    fluid.event.dispatchListener = function (instantiator, that, listener, eventName, eventSpec) {
        return function () {
            var demandspec = fluid.determineDemands(instantiator, that, eventName);
            if (demandspec.args.length === 0 && eventSpec.args) {
                demandspec.args = eventSpec.args
            }
            var resolved = fluid.embodyDemands(instantiator, that, demandspec, arguments, {passArgs:true, componentOptions:eventSpec});
            listener.apply(null, resolved.args)
        }
    };
    fluid.event.resolveEvent = function (that, eventName, eventSpec) {
        return fluid.withInstantiator(that, function (instantiator) {
            if (typeof(eventSpec) === "string") {
                var firer = fluid.expandOptions(eventSpec, that);
                if (!firer) {
                    fluid.fail("Error in fluid.event.resolveEvent - context path " + eventSpec + " could not be looked up to a valid event firer")
                }
                return firer
            } else {
                var event = eventSpec.event;
                var origin;
                if (!event) {
                    fluid.fail("Event specification for event with name " + eventName + " does not include a base event specification")
                }
                if (event.charAt(0) === "{") {
                    origin = fluid.expandOptions(event, that)
                } else {
                    origin = that.events[event]
                }
                if (!origin) {
                    fluid.fail("Error in event specification - could not resolve base event reference " + event + " to an event firer")
                }
                var firer = {};
                fluid.each(["fire", "removeListener"], function (method) {
                    firer[method] = function () {
                        origin[method].apply(null, arguments)
                    }
                });
                firer.addListener = function (listener, namespace, predicate, priority) {
                    origin.addListener(fluid.event.dispatchListener(instantiator, that, listener, eventName, eventSpec), namespace, predicate, priority)
                };
                return firer
            }
        })
    };
    fluid.registerNamespace("fluid.expander");
    fluid.expander.preserveFromExpansion = function (options) {
        var preserve = {};
        var preserveList = fluid.arrayToHash(["mergePolicy", "mergeAllOptions", "components", "invokers", "events", "listeners", "transformOptions"]);
        fluid.each(options.mergePolicy, function (value, key) {
            if (fluid.mergePolicyIs(value, "noexpand")) {
                preserveList[key] = true
            }
        });
        fluid.each(preserveList, function (xvalue, path) {
            var pen = fluid.model.getPenultimate(options, path);
            var value = pen.root[pen.last];
            delete pen.root[pen.last];
            fluid.set(preserve, path, value)
        });
        return{restore:function (target) {
            fluid.each(preserveList, function (xvalue, path) {
                var preserved = fluid.get(preserve, path);
                if (preserved !== undefined) {
                    fluid.set(target, path, preserved)
                }
            })
        }}
    };
    fluid.expandOptions = function (args, that, localRecord, outerExpandOptions) {
        if (!args) {
            return args
        }
        return fluid.withInstantiator(that, function (instantiator) {
            var expandOptions = makeStackResolverOptions(instantiator, that, localRecord, outerExpandOptions);
            expandOptions.noCopy = true;
            var pres;
            if (!fluid.isArrayable(args) && !fluid.isPrimitive(args)) {
                pres = fluid.expander.preserveFromExpansion(args)
            }
            var expanded = fluid.expander.expandLight(args, expandOptions);
            if (pres) {
                pres.restore(expanded)
            }
            return expanded
        })
    };
    fluid.locateTransformationRecord = function (that) {
        return fluid.withInstantiator(that, function (instantiator) {
            var matches = fluid.locateAllDemands(instantiator, that, ["fluid.transformOptions"]);
            return fluid.find(matches, function (match) {
                return match.uncess === 0 && fluid.contains(match.spec.contexts, that.typeName) ? match.spec.spec : undefined
            })
        })
    };
    fluid.hashToArray = function (hash) {
        var togo = [];
        fluid.each(hash, function (value, key) {
            togo.push(key)
        });
        return togo
    };
    fluid.localRecordExpected = ["type", "options", "arguments", "mergeOptions", "mergeAllOptions", "createOnEvent", "priority"];
    fluid.checkComponentRecord = function (defaults, localRecord) {
        var expected = fluid.arrayToHash(fluid.localRecordExpected);
        fluid.each(defaults.argumentMap, function (value, key) {
            expected[key] = true
        });
        fluid.each(localRecord, function (value, key) {
            if (!expected[key]) {
                fluid.fail("Probable error in subcomponent record - key \"" + key + "\" found, where the only legal options are " + fluid.hashToArray(expected).join(", "))
            }
        })
    };
    fluid.expandComponentOptions = function (defaults, userOptions, that) {
        if (userOptions && userOptions.localRecord) {
            fluid.checkComponentRecord(defaults, userOptions.localRecord)
        }
        defaults = fluid.expandOptions(fluid.copy(defaults), that);
        var localRecord = {};
        if (userOptions && userOptions.marker === fluid.EXPAND) {
            var localOptions = fluid.get(userOptions, "localRecord.options");
            if (localOptions) {
                if (defaults && defaults.mergePolicy) {
                    localOptions.mergePolicy = defaults.mergePolicy
                }
                localRecord.options = fluid.expandOptions(localOptions, that)
            }
            localRecord["arguments"] = fluid.get(userOptions, "localRecord.arguments");
            var toExpand = userOptions.value;
            userOptions = fluid.expandOptions(toExpand, that, localRecord, {direct:true})
        }
        localRecord.directOptions = userOptions;
        if (!localRecord.options) {
            localRecord.options = userOptions
        }
        var mergeOptions = (userOptions && userOptions.mergeAllOptions) || ["{directOptions}"];
        var togo = fluid.transform(mergeOptions, function (path) {
            return path === "{directOptions}" ? localRecord.directOptions : fluid.expandOptions(path, that, localRecord, {direct:true})
        });
        var transRec = fluid.locateTransformationRecord(that);
        if (transRec) {
            togo[0].transformOptions = transRec.options
        }
        return[defaults].concat(togo)
    };
    fluid.expandComponentOptions = fluid.wrapActivity(fluid.expandComponentOptions, ["    while expanding component options ", "arguments.1.value", " with record ", "arguments.1", " for component ", "arguments.2"]);
    fluid.initDependent = function (that, name, userInstantiator, directArgs) {
        if (!that || that[name]) {
            return
        }
        fluid.log("Beginning instantiation of component with name \"" + name + "\" as child of " + fluid.dumpThat(that));
        directArgs = directArgs || [];
        var root = fluid.threadLocal();
        if (userInstantiator) {
            var existing = root["fluid.instantiator"];
            if (existing && existing !== userInstantiator) {
                fluid.fail("Error in initDependent: user instantiator supplied with id " + userInstantiator.id + " which differs from that for currently active instantiation with id " + existing.id)
            } else {
                root["fluid.instantiator"] = userInstantiator
            }
        }
        var component = that.options.components[name];
        fluid.withInstantiator(that, function (instantiator) {
            if (typeof(component) === "string") {
                that[name] = fluid.expandOptions([component], that)[0]
            } else if (component.type) {
                var invokeSpec = fluid.resolveDemands(instantiator, that, [component.type, name], directArgs, {componentRecord:component});
                instantiator.pushUpcomingInstantiation(that, name);
                fluid.tryCatch(function () {
                    that[inCreationMarker] = true;
                    var instance = fluid.initSubcomponentImpl(that, {type:invokeSpec.funcName}, invokeSpec.args);
                    var path = fluid.composePath(instantiator.idToPath[that.id] || "", name);
                    var existing = instantiator.pathToComponent[path];
                    if (existing && existing !== instance) {
                        instantiator.clearComponent(that, name, existing, null, true)
                    }
                    if (instance && instance.typeName && instance.id && instance !== existing) {
                        instantiator.recordKnownComponent(that, instance, name)
                    }
                    that[name] = instance
                }, null, function () {
                    delete that[inCreationMarker];
                    instantiator.pushUpcomingInstantiation()
                })
            } else {
                that[name] = component
            }
        }, ["    while instantiating dependent component with name \"" + name + "\" with record ", component, " as child of ", that]);
        fluid.log("Finished instantiation of component with name \"" + name + "\" as child of " + fluid.dumpThat(that))
    };
    fluid.withInstantiator = function (that, func, message) {
        var root = fluid.threadLocal();
        var instantiator = root["fluid.instantiator"];
        if (!instantiator) {
            instantiator = root["fluid.instantiator"] = fluid.instantiator()
        }
        return fluid.pushActivity(function () {
            return fluid.tryCatch(function () {
                if (that) {
                    instantiator.recordComponent(that)
                }
                instantiator.stack(1);
                return func(instantiator)
            }, null, function () {
                var count = instantiator.stack(-1);
                if (count === 0) {
                    delete root["fluid.instantiator"]
                }
            })
        }, message)
    };
    fluid.bindDeferredComponent = function (that, componentName, component, instantiator) {
        var events = fluid.makeArray(component.createOnEvent);
        fluid.each(events, function (eventName) {
            that.events[eventName].addListener(function () {
                if (that[componentName]) {
                    instantiator.clearComponent(that, componentName)
                }
                fluid.initDependent(that, componentName, instantiator)
            }, null, null, component.priority)
        })
    };
    fluid.priorityForComponent = function (component) {
        return component.priority ? component.priority : (component.type === "fluid.typeFount" || fluid.hasGrade(fluid.defaults(component.type), "fluid.typeFount")) ? "first" : undefined
    };
    fluid.initDependents = function (that) {
        var options = that.options;
        var components = options.components || {};
        var componentSort = {};
        fluid.withInstantiator(that, function (instantiator) {
            fluid.each(components, function (component, name) {
                if (!component.createOnEvent) {
                    var priority = fluid.priorityForComponent(component);
                    componentSort[name] = {key:name, priority:fluid.event.mapPriority(priority, 0)}
                } else {
                    fluid.bindDeferredComponent(that, name, component, instantiator)
                }
            });
            var componentList = fluid.event.sortListeners(componentSort);
            fluid.each(componentList, function (entry) {
                fluid.initDependent(that, entry.key)
            });
            var invokers = options.invokers || {};
            for (var name in invokers) {
                var invokerec = invokers[name];
                var funcName = typeof(invokerec) === "string" ? invokerec : null;
                that[name] = fluid.withInstantiator(that, function (instantiator) {
                    fluid.log("Beginning instantiation of invoker with name \"" + name + "\" as child of " + fluid.dumpThat(that));
                    return fluid.makeInvoker(instantiator, that, funcName ? null : invokerec, funcName)
                }, ["    while instantiating invoker with name \"" + name + "\" with record ", invokerec, " as child of ", that]);
                fluid.log("Finished instantiation of invoker with name \"" + name + "\" as child of " + fluid.dumpThat(that))
            }
        })
    };
    fluid.staticEnvironment = fluid.typeTag("fluid.staticEnvironment");
    fluid.staticEnvironment.environmentClass = fluid.typeTag("fluid.browser");
    fluid.demands("fluid.threadLocal", "fluid.browser", {funcName:"fluid.singleThreadLocal"});
    var singleThreadLocal = fluid.typeTag("fluid.dynamicEnvironment");
    fluid.singleThreadLocal = function () {
        return singleThreadLocal
    };
    fluid.threadLocal = function () {
        var demands = fluid.locateDemands(fluid.freeInstantiator, null, ["fluid.threadLocal"]);
        return fluid.invokeGlobalFunction(demands.funcName, arguments)
    };
    function applyLocalChange(applier, type, path, value) {
        var change = {type:type, path:path, value:value};
        applier.fireChangeRequest(change)
    }

    fluid.withEnvironment = function (envAdd, func, prefix) {
        prefix = prefix || "";
        var root = fluid.threadLocal();
        var applier = fluid.makeChangeApplier(root, {thin:true});
        return fluid.tryCatch(function () {
            for (var key in envAdd) {
                applyLocalChange(applier, "ADD", fluid.model.composePath(prefix, key), envAdd[key])
            }
            $.extend(root, envAdd);
            return func()
        }, null, function () {
            for (var key in envAdd) {
                applyLocalChange(applier, "DELETE", fluid.model.composePath(prefix, key))
            }
        })
    };
    fluid.makeEnvironmentFetcher = function (prefix, directModel) {
        return function (parsed) {
            var env = fluid.get(fluid.threadLocal(), prefix);
            return fluid.fetchContextReference(parsed, directModel, env)
        }
    };
    fluid.extractEL = function (string, options) {
        if (options.ELstyle === "ALL") {
            return string
        } else if (options.ELstyle.length === 1) {
            if (string.charAt(0) === options.ELstyle) {
                return string.substring(1)
            }
        } else if (options.ELstyle === "${}") {
            var i1 = string.indexOf("${");
            var i2 = string.lastIndexOf("}");
            if (i1 === 0 && i2 !== -1) {
                return string.substring(2, i2)
            }
        }
    };
    fluid.extractELWithContext = function (string, options) {
        var EL = fluid.extractEL(string, options);
        if (EL && EL.charAt(0) === "{") {
            return fluid.parseContextReference(EL, 0)
        }
        return EL ? {path:EL} : EL
    };
    fluid.parseContextReference = function (reference, index, delimiter) {
        var endcpos = reference.indexOf("}", index + 1);
        if (endcpos === -1) {
            fluid.fail("Cannot parse context reference \"" + reference + "\": Malformed context reference without }")
        }
        var context = reference.substring(index + 1, endcpos);
        var endpos = delimiter ? reference.indexOf(delimiter, endcpos + 1) : reference.length;
        var path = reference.substring(endcpos + 1, endpos);
        if (path.charAt(0) === ".") {
            path = path.substring(1)
        }
        return{context:context, path:path, endpos:endpos}
    };
    fluid.renderContextReference = function (parsed) {
        return"{" + parsed.context + "}" + parsed.path
    };
    fluid.fetchContextReference = function (parsed, directModel, env) {
        var base = parsed.context ? env[parsed.context] : directModel;
        if (!base) {
            return base
        }
        return fluid.get(base, parsed.path)
    };
    fluid.resolveContextValue = function (string, options) {
        if (options.bareContextRefs && string.charAt(0) === "{") {
            var parsed = fluid.parseContextReference(string, 0);
            return options.fetcher(parsed)
        } else if (options.ELstyle && options.ELstyle !== "${}") {
            var parsed = fluid.extractELWithContext(string, options);
            if (parsed) {
                return options.fetcher(parsed)
            }
        }
        while (typeof(string) === "string") {
            var i1 = string.indexOf("${");
            var i2 = string.indexOf("}", i1 + 2);
            if (i1 !== -1 && i2 !== -1) {
                var parsed;
                if (string.charAt(i1 + 2) === "{") {
                    parsed = fluid.parseContextReference(string, i1 + 2, "}");
                    i2 = parsed.endpos
                } else {
                    parsed = {path:string.substring(i1 + 2, i2)}
                }
                var subs = options.fetcher(parsed);
                var all = (i1 === 0 && i2 === string.length - 1);
                if (subs === undefined || subs === null) {
                    return subs
                }
                string = all ? subs : string.substring(0, i1) + subs + string.substring(i2 + 1)
            } else {
                break
            }
        }
        return string
    };
    fluid.resolveContextValue = fluid.wrapActivity(fluid.resolveContextValue, ["    while resolving context value ", "arguments.0"]);
    function resolveEnvironmentImpl(obj, options) {
        fluid.guardCircularity(options.seenIds, obj, "expansion", " - please ensure options are not circularly connected, or protect from expansion using the \"noexpand\" policy or expander");
        function recurse(arg) {
            return resolveEnvironmentImpl(arg, options)
        }

        if (typeof(obj) === "string" && !options.noValue) {
            return fluid.resolveContextValue(obj, options)
        } else if (fluid.isPrimitive(obj) || obj.nodeType !== undefined || obj.jquery) {
            return obj
        } else if (options.filter) {
            return options.filter(obj, recurse, options)
        } else {
            return(options.noCopy ? fluid.each : fluid.transform)(obj, function (value, key) {
                return resolveEnvironmentImpl(value, options)
            })
        }
    }

    fluid.defaults("fluid.resolveEnvironment", {ELstyle:"${}", seenIds:{}, bareContextRefs:true});
    fluid.resolveEnvironment = function (obj, options) {
        options = $.extend(true, {}, fluid.rawDefaults("fluid.resolveEnvironment"), options);
        return resolveEnvironmentImpl(obj, options)
    };
    fluid.expander.deferredCall = function (target, source, recurse) {
        var expander = source.expander;
        var args = (!expander.args || fluid.isArrayable(expander.args)) ? expander.args : $.makeArray(expander.args);
        args = recurse(args);
        return fluid.invokeGlobalFunction(expander.func, args)
    };
    fluid.deferredCall = fluid.expander.deferredCall;
    fluid.deferredInvokeCall = function (target, source, recurse) {
        var expander = source.expander;
        var args = (!expander.args || fluid.isArrayable(expander.args)) ? expander.args : $.makeArray(expander.args);
        args = recurse(args);
        return fluid.invoke(expander.func, args)
    };
    fluid.expander.noexpand = function (target, source) {
        return $.extend(target, source.expander.tree)
    };
    fluid.noexpand = fluid.expander.noexpand;
    fluid.expander.lightFilter = function (obj, recurse, options) {
        var togo;
        if (fluid.isArrayable(obj)) {
            togo = options.noCopy ? obj : [];
            fluid.each(obj, function (value, key) {
                togo[key] = recurse(value)
            })
        } else {
            togo = options.noCopy ? obj : {};
            for (var key in obj) {
                var value = obj[key];
                var expander;
                if (key === "expander" && !(options.expandOnly && options.expandOnly[value.type])) {
                    expander = fluid.getGlobalValue(value.type);
                    if (expander) {
                        return expander.call(null, togo, obj, recurse, options)
                    }
                }
                if (key !== "expander" || !expander) {
                    togo[key] = recurse(value)
                }
            }
        }
        return options.noCopy ? obj : togo
    };
    fluid.expander.expandLight = function (source, expandOptions) {
        var options = $.extend({}, expandOptions);
        options.filter = fluid.expander.lightFilter;
        return fluid.resolveEnvironment(source, options)
    }
})(jQuery, fluid_1_4);
(function ($, fluid) {
    var resourceCache = {};
    var pendingClass = {};
    fluid.fetchResources = function (resourceSpecs, callback, options) {
        var that = fluid.initLittleComponent("fluid.fetchResources", options);
        that.resourceSpecs = resourceSpecs;
        that.callback = callback;
        that.operate = function () {
            fluid.fetchResources.fetchResourcesImpl(that)
        };
        fluid.each(resourceSpecs, function (resourceSpec) {
            resourceSpec.recurseFirer = fluid.event.getEventFirer();
            resourceSpec.recurseFirer.addListener(that.operate);
            if (resourceSpec.url && !resourceSpec.href) {
                resourceSpec.href = resourceSpec.url
            }
        });
        if (that.options.amalgamateClasses) {
            fluid.fetchResources.amalgamateClasses(resourceSpecs, that.options.amalgamateClasses, that.operate)
        }
        that.operate();
        return that
    };
    fluid.fetchResources.amalgamateClasses = function (specs, classes, operator) {
        fluid.each(classes, function (clazz) {
            var pending = pendingClass[clazz];
            fluid.each(pending, function (pendingrec, canon) {
                specs[clazz + "!" + canon] = pendingrec;
                pendingrec.recurseFirer.addListener(operator)
            })
        })
    };
    fluid.fetchResources.timeSuccessCallback = function (resourceSpec) {
        if (resourceSpec.timeSuccess && resourceSpec.options && resourceSpec.options.success) {
            var success = resourceSpec.options.success;
            resourceSpec.options.success = function () {
                var startTime = new Date();
                var ret = success.apply(null, arguments);
                fluid.log("External callback for URL " + resourceSpec.href + " completed - callback time: " + (new Date().getTime() - startTime.getTime()) + "ms");
                return ret
            }
        }
    };
    function canonUrl(url) {
        return url
    }

    fluid.fetchResources.clearResourceCache = function (url) {
        if (url) {
            delete resourceCache[canonUrl(url)]
        } else {
            fluid.clear(resourceCache)
        }
    };
    fluid.fetchResources.handleCachedRequest = function (resourceSpec, response) {
        var canon = canonUrl(resourceSpec.href);
        var cached = resourceCache[canon];
        if (cached.$$firer$$) {
            fluid.log("Handling request for " + canon + " from cache");
            var fetchClass = resourceSpec.fetchClass;
            if (fetchClass && pendingClass[fetchClass]) {
                fluid.log("Clearing pendingClass entry for class " + fetchClass);
                delete pendingClass[fetchClass][canon]
            }
            resourceCache[canon] = response;
            cached.fire(response)
        }
    };
    fluid.fetchResources.completeRequest = function (thisSpec, recurseCall) {
        thisSpec.queued = false;
        thisSpec.completeTime = new Date();
        fluid.log("Request to URL " + thisSpec.href + " completed - total elapsed time: " + (thisSpec.completeTime.getTime() - thisSpec.initTime.getTime()) + "ms");
        thisSpec.recurseFirer.fire()
    };
    fluid.fetchResources.makeResourceCallback = function (thisSpec) {
        return{success:function (response) {
            thisSpec.resourceText = response;
            thisSpec.resourceKey = thisSpec.href;
            if (thisSpec.forceCache) {
                fluid.fetchResources.handleCachedRequest(thisSpec, response)
            }
            fluid.fetchResources.completeRequest(thisSpec)
        }, error:function (response, textStatus, errorThrown) {
            thisSpec.fetchError = {status:response.status, textStatus:response.textStatus, errorThrown:errorThrown};
            fluid.fetchResources.completeRequest(thisSpec)
        }}
    };
    fluid.fetchResources.issueCachedRequest = function (resourceSpec, options) {
        var canon = canonUrl(resourceSpec.href);
        var cached = resourceCache[canon];
        if (!cached) {
            fluid.log("First request for cached resource with url " + canon);
            cached = fluid.event.getEventFirer();
            cached.$$firer$$ = true;
            resourceCache[canon] = cached;
            var fetchClass = resourceSpec.fetchClass;
            if (fetchClass) {
                if (!pendingClass[fetchClass]) {
                    pendingClass[fetchClass] = {}
                }
                pendingClass[fetchClass][canon] = resourceSpec
            }
            options.cache = false;
            $.ajax(options)
        } else {
            if (!cached.$$firer$$) {
                options.success(cached)
            } else {
                fluid.log("Request for cached resource which is in flight: url " + canon);
                cached.addListener(function (response) {
                    options.success(response)
                })
            }
        }
    };
    fluid.fetchResources.composeCallbacks = function (internal, external) {
        return external ? function () {
            try {
                external.apply(null, arguments)
            } catch (e) {
                fluid.log("Exception applying external fetchResources callback: " + e)
            }
            internal.apply(null, arguments)
        } : internal
    };
    fluid.fetchResources.composePolicy = function (target, source, key) {
        return fluid.fetchResources.composeCallbacks(target, source)
    };
    fluid.defaults("fluid.fetchResources.issueRequest", {mergePolicy:{success:fluid.fetchResources.composePolicy, error:fluid.fetchResources.composePolicy, url:"reverse"}});
    fluid.fetchResources.issueRequest = function (resourceSpec, key) {
        var thisCallback = fluid.fetchResources.makeResourceCallback(resourceSpec);
        var options = {url:resourceSpec.href, success:thisCallback.success, error:thisCallback.error, dataType:"text"};
        fluid.fetchResources.timeSuccessCallback(resourceSpec);
        fluid.merge(fluid.defaults("fluid.fetchResources.issueRequest").mergePolicy, options, resourceSpec.options);
        resourceSpec.queued = true;
        resourceSpec.initTime = new Date();
        fluid.log("Request with key " + key + " queued for " + resourceSpec.href);
        if (resourceSpec.forceCache) {
            fluid.fetchResources.issueCachedRequest(resourceSpec, options)
        } else {
            $.ajax(options)
        }
    };
    fluid.fetchResources.fetchResourcesImpl = function (that) {
        var complete = true;
        var allSync = true;
        var resourceSpecs = that.resourceSpecs;
        for (var key in resourceSpecs) {
            var resourceSpec = resourceSpecs[key];
            if (!resourceSpec.options || resourceSpec.options.async) {
                allSync = false
            }
            if (resourceSpec.href && !resourceSpec.completeTime) {
                if (!resourceSpec.queued) {
                    fluid.fetchResources.issueRequest(resourceSpec, key)
                }
                if (resourceSpec.queued) {
                    complete = false
                }
            } else if (resourceSpec.nodeId && !resourceSpec.resourceText) {
                var node = document.getElementById(resourceSpec.nodeId);
                resourceSpec.resourceText = fluid.dom.getElementText(node);
                resourceSpec.resourceKey = resourceSpec.nodeId
            }
        }
        if (complete && that.callback && !that.callbackCalled) {
            that.callbackCalled = true;
            if ($.browser.mozilla && !allSync) {
                setTimeout(function () {
                    that.callback(resourceSpecs)
                }, 1)
            } else {
                that.callback(resourceSpecs)
            }
        }
    };
    fluid.fetchResources.primeCacheFromResources = function (componentName) {
        var resources = fluid.defaults(componentName).resources;
        var that = {typeName:"fluid.fetchResources.primeCacheFromResources"};
        var expanded = (fluid.expandOptions ? fluid.expandOptions : fluid.identity)(fluid.copy(resources), that);
        fluid.fetchResources(expanded)
    };
    fluid.registerNamespace("fluid.expander");
    fluid.expander.makeDefaultFetchOptions = function (successdisposer, failid, options) {
        return $.extend(true, {dataType:"text"}, options, {success:function (response, environmentdisposer) {
            var json = JSON.parse(response);
            environmentdisposer(successdisposer(json))
        }, error:function (response, textStatus) {
            fluid.log("Error fetching " + failid + ": " + textStatus)
        }})
    };
    fluid.expander.makeFetchExpander = function (options) {
        return{expander:{type:"fluid.expander.deferredFetcher", href:options.url, options:fluid.expander.makeDefaultFetchOptions(options.disposer, options.url, options.options), resourceSpecCollector:"{resourceSpecCollector}", fetchKey:options.fetchKey}}
    };
    fluid.expander.deferredFetcher = function (target, source, recurse, expandOptions) {
        var expander = source.expander;
        var spec = fluid.copy(expander);
        var collector = fluid.resolveEnvironment(expander.resourceSpecCollector, expandOptions);
        delete spec.type;
        delete spec.resourceSpecCollector;
        delete spec.fetchKey;
        var environmentdisposer = function (disposed) {
            $.extend(target, disposed)
        };
        spec.options.success = function (response) {
            expander.options.success(response, environmentdisposer)
        };
        var key = expander.fetchKey || fluid.allocateGuid();
        collector[key] = spec;
        return target
    }
})(jQuery, fluid_1_4);
(function ($, fluid) {
    fluid.defaults("fluid.ariaLabeller", {labelAttribute:"aria-label", liveRegionMarkup:"<div class=\"liveRegion fl-offScreen-hidden\" aria-live=\"polite\"></div>", liveRegionId:"fluid-ariaLabeller-liveRegion", invokers:{generateLiveElement:{funcName:"fluid.ariaLabeller.generateLiveElement", args:["{ariaLabeller}"]}}});
    fluid.ariaLabeller = function (element, options) {
        var that = fluid.initView("fluid.ariaLabeller", element, options);
        fluid.initDependents(that);
        that.update = function (newOptions) {
            newOptions = newOptions || that.options;
            that.container.attr(that.options.labelAttribute, newOptions.text);
            if (newOptions.dynamicLabel) {
                var live = fluid.jById(that.options.liveRegionId);
                if (live.length === 0) {
                    live = that.generateLiveElement()
                }
                live.text(newOptions.text)
            }
        };
        that.update();
        return that
    };
    fluid.ariaLabeller.generateLiveElement = function (that) {
        var liveEl = $(that.options.liveRegionMarkup);
        liveEl.prop("id", that.options.liveRegionId);
        $("body").append(liveEl);
        return liveEl
    };
    var LABEL_KEY = "aria-labelling";
    fluid.getAriaLabeller = function (element) {
        element = $(element);
        var that = fluid.getScopedData(element, LABEL_KEY);
        return that
    };
    fluid.updateAriaLabel = function (element, text, options) {
        options = $.extend({}, options || {}, {text:text});
        var that = fluid.getAriaLabeller(element);
        if (!that) {
            that = fluid.ariaLabeller(element, options);
            fluid.setScopedData(element, LABEL_KEY, that)
        } else {
            that.update(options)
        }
        return that
    };
    fluid.deadMansBlur = function (control, options) {
        var that = fluid.initLittleComponent("fluid.deadMansBlur", options);
        that.blurPending = false;
        that.lastCancel = 0;
        $(control).bind("focusout", function (event) {
            fluid.log("Starting blur timer for element " + fluid.dumpEl(event.target));
            var now = new Date().getTime();
            fluid.log("back delay: " + (now - that.lastCancel));
            if (now - that.lastCancel > that.options.backDelay) {
                that.blurPending = true
            }
            setTimeout(function () {
                if (that.blurPending) {
                    that.options.handler(control)
                }
            }, that.options.delay)
        });
        that.canceller = function (event) {
            fluid.log("Cancellation through " + event.type + " on " + fluid.dumpEl(event.target));
            that.lastCancel = new Date().getTime();
            that.blurPending = false
        };
        fluid.each(that.options.exclusions, function (exclusion) {
            exclusion = $(exclusion);
            fluid.each(exclusion, function (excludeEl) {
                $(excludeEl).bind("focusin", that.canceller).bind("fluid-focus", that.canceller).click(that.canceller).mousedown(that.canceller)
            })
        });
        return that
    };
    fluid.defaults("fluid.deadMansBlur", {delay:150, backDelay:100})
})(jQuery, fluid_1_4);
(function ($, fluid) {
    fluid.thatistBridge = function (name, peer) {
        var togo = function (funcname) {
            var segs = funcname.split(".");
            var move = peer;
            for (var i = 0; i < segs.length; ++i) {
                move = move[segs[i]]
            }
            var args = [this];
            if (arguments.length === 2) {
                args = args.concat($.makeArray(arguments[1]))
            }
            var ret = move.apply(null, args);
            this.that = function () {
                return ret
            }
            var type = typeof(ret);
            return!ret || type === "string" || type === "number" || type === "boolean" || ret && ret.length !== undefined ? ret : this
        };
        $.fn[name] = togo;
        return togo
    };
    fluid.thatistBridge("fluid", fluid);
    fluid.thatistBridge("fluid_1_4", fluid_1_4);
    var normalizeTabindexName = function () {
        return $.browser.msie ? "tabIndex" : "tabindex"
    };
    var canHaveDefaultTabindex = function (elements) {
        if (elements.length <= 0) {
            return false
        }
        return $(elements[0]).is("a, input, button, select, area, textarea, object")
    };
    var getValue = function (elements) {
        if (elements.length <= 0) {
            return undefined
        }
        if (!fluid.tabindex.hasAttr(elements)) {
            return canHaveDefaultTabindex(elements) ? Number(0) : undefined
        }
        var value = elements.attr(normalizeTabindexName());
        return Number(value)
    };
    var setValue = function (elements, toIndex) {
        return elements.each(function (i, item) {
            $(item).attr(normalizeTabindexName(), toIndex)
        })
    };
    fluid.tabindex = function (target, toIndex) {
        target = $(target);
        if (toIndex !== null && toIndex !== undefined) {
            return setValue(target, toIndex)
        } else {
            return getValue(target)
        }
    };
    fluid.tabindex.remove = function (target) {
        target = $(target);
        return target.each(function (i, item) {
            $(item).removeAttr(normalizeTabindexName())
        })
    };
    fluid.tabindex.hasAttr = function (target) {
        target = $(target);
        if (target.length <= 0) {
            return false
        }
        var togo = target.map(function () {
            var attributeNode = this.getAttributeNode(normalizeTabindexName());
            return attributeNode ? attributeNode.specified : false
        });
        return togo.length === 1 ? togo[0] : togo
    };
    fluid.tabindex.has = function (target) {
        target = $(target);
        return fluid.tabindex.hasAttr(target) || canHaveDefaultTabindex(target)
    };
    fluid.a11y = $.a11y || {};
    fluid.a11y.orientation = {HORIZONTAL:0, VERTICAL:1, BOTH:2};
    var UP_DOWN_KEYMAP = {next:$.ui.keyCode.DOWN, previous:$.ui.keyCode.UP};
    var LEFT_RIGHT_KEYMAP = {next:$.ui.keyCode.RIGHT, previous:$.ui.keyCode.LEFT};
    var unwrap = function (element) {
        return element.jquery ? element[0] : element
    };
    var makeElementsTabFocussable = function (elements) {
        elements.each(function (idx, item) {
            item = $(item);
            if (!item.fluid("tabindex.has") || item.fluid("tabindex") < 0) {
                item.fluid("tabindex", 0)
            }
        })
    };
    fluid.tabbable = function (target) {
        target = $(target);
        makeElementsTabFocussable(target)
    };
    var CONTEXT_KEY = "selectionContext";
    var NO_SELECTION = -32768;
    var cleanUpWhenLeavingContainer = function (selectionContext) {
        if (selectionContext.activeItemIndex !== NO_SELECTION) {
            if (selectionContext.options.onLeaveContainer) {
                selectionContext.options.onLeaveContainer(selectionContext.selectables[selectionContext.activeItemIndex])
            } else if (selectionContext.options.onUnselect) {
                selectionContext.options.onUnselect(selectionContext.selectables[selectionContext.activeItemIndex])
            }
        }
        if (!selectionContext.options.rememberSelectionState) {
            selectionContext.activeItemIndex = NO_SELECTION
        }
    };
    var drawSelection = function (elementToSelect, handler) {
        if (handler) {
            handler(elementToSelect)
        }
    };
    var eraseSelection = function (selectedElement, handler) {
        if (handler && selectedElement) {
            handler(selectedElement)
        }
    };
    var unselectElement = function (selectedElement, selectionContext) {
        eraseSelection(selectedElement, selectionContext.options.onUnselect)
    };
    var selectElement = function (elementToSelect, selectionContext) {
        unselectElement(selectionContext.selectedElement(), selectionContext);
        elementToSelect = unwrap(elementToSelect);
        var newIndex = selectionContext.selectables.index(elementToSelect);
        if (newIndex === -1) {
            return
        }
        selectionContext.activeItemIndex = newIndex;
        drawSelection(elementToSelect, selectionContext.options.onSelect)
    };
    var selectableFocusHandler = function (selectionContext) {
        return function (evt) {
            $(evt.target).fluid("tabindex", 0);
            selectElement(evt.target, selectionContext);
            return evt.stopPropagation()
        }
    };
    var selectableBlurHandler = function (selectionContext) {
        return function (evt) {
            $(evt.target).fluid("tabindex", selectionContext.options.selectablesTabindex);
            unselectElement(evt.target, selectionContext);
            return evt.stopPropagation()
        }
    };
    var reifyIndex = function (sc_that) {
        var elements = sc_that.selectables;
        if (sc_that.activeItemIndex >= elements.length) {
            sc_that.activeItemIndex = 0
        }
        if (sc_that.activeItemIndex < 0 && sc_that.activeItemIndex !== NO_SELECTION) {
            sc_that.activeItemIndex = elements.length - 1
        }
        if (sc_that.activeItemIndex >= 0) {
            fluid.focus(elements[sc_that.activeItemIndex])
        }
    };
    var prepareShift = function (selectionContext) {
        var selElm = selectionContext.selectedElement();
        if (selElm) {
            fluid.blur(selElm)
        }
        unselectElement(selectionContext.selectedElement(), selectionContext);
        if (selectionContext.activeItemIndex === NO_SELECTION) {
            selectionContext.activeItemIndex = -1
        }
    };
    var focusNextElement = function (selectionContext) {
        prepareShift(selectionContext);
        ++selectionContext.activeItemIndex;
        reifyIndex(selectionContext)
    };
    var focusPreviousElement = function (selectionContext) {
        prepareShift(selectionContext);
        --selectionContext.activeItemIndex;
        reifyIndex(selectionContext)
    };
    var arrowKeyHandler = function (selectionContext, keyMap, userHandlers) {
        return function (evt) {
            if (evt.which === keyMap.next) {
                focusNextElement(selectionContext);
                evt.preventDefault()
            } else if (evt.which === keyMap.previous) {
                focusPreviousElement(selectionContext);
                evt.preventDefault()
            }
        }
    };
    var getKeyMapForDirection = function (direction) {
        var keyMap;
        if (direction === fluid.a11y.orientation.HORIZONTAL) {
            keyMap = LEFT_RIGHT_KEYMAP
        } else if (direction === fluid.a11y.orientation.VERTICAL) {
            keyMap = UP_DOWN_KEYMAP
        }
        return keyMap
    };
    var tabKeyHandler = function (selectionContext) {
        return function (evt) {
            if (evt.which !== $.ui.keyCode.TAB) {
                return
            }
            cleanUpWhenLeavingContainer(selectionContext);
            if (evt.shiftKey) {
                selectionContext.focusIsLeavingContainer = true
            }
        }
    };
    var containerFocusHandler = function (selectionContext) {
        return function (evt) {
            var shouldOrig = selectionContext.options.autoSelectFirstItem;
            var shouldSelect = typeof(shouldOrig) === "function" ? shouldOrig() : shouldOrig;
            if (selectionContext.focusIsLeavingContainer) {
                shouldSelect = false
            }
            if (shouldSelect && evt.target === selectionContext.container.get(0)) {
                if (selectionContext.activeItemIndex === NO_SELECTION) {
                    selectionContext.activeItemIndex = 0
                }
                fluid.focus(selectionContext.selectables[selectionContext.activeItemIndex])
            }
            return evt.stopPropagation()
        }
    };
    var containerBlurHandler = function (selectionContext) {
        return function (evt) {
            selectionContext.focusIsLeavingContainer = false;
            return evt.stopPropagation()
        }
    };
    var makeElementsSelectable = function (container, defaults, userOptions) {
        var options = $.extend(true, {}, defaults, userOptions);
        var keyMap = getKeyMapForDirection(options.direction);
        var selectableElements = options.selectableElements ? options.selectableElements : container.find(options.selectableSelector);
        var that = {container:container, activeItemIndex:NO_SELECTION, selectables:selectableElements, focusIsLeavingContainer:false, options:options};
        that.selectablesUpdated = function (focusedItem) {
            if (typeof(that.options.selectablesTabindex) === "number") {
                that.selectables.fluid("tabindex", that.options.selectablesTabindex)
            }
            that.selectables.unbind("focus." + CONTEXT_KEY);
            that.selectables.unbind("blur." + CONTEXT_KEY);
            that.selectables.bind("focus." + CONTEXT_KEY, selectableFocusHandler(that));
            that.selectables.bind("blur." + CONTEXT_KEY, selectableBlurHandler(that));
            if (keyMap && that.options.noBubbleListeners) {
                that.selectables.unbind("keydown." + CONTEXT_KEY);
                that.selectables.bind("keydown." + CONTEXT_KEY, arrowKeyHandler(that, keyMap))
            }
            if (focusedItem) {
                selectElement(focusedItem, that)
            } else {
                reifyIndex(that)
            }
        };
        that.refresh = function () {
            if (!that.options.selectableSelector) {
                throw("Cannot refresh selectable context which was not initialised by a selector")
            }
            that.selectables = container.find(options.selectableSelector);
            that.selectablesUpdated()
        };
        that.selectedElement = function () {
            return that.activeItemIndex < 0 ? null : that.selectables[that.activeItemIndex]
        };
        if (keyMap && !that.options.noBubbleListeners) {
            container.keydown(arrowKeyHandler(that, keyMap))
        }
        container.keydown(tabKeyHandler(that));
        container.focus(containerFocusHandler(that));
        container.blur(containerBlurHandler(that));
        that.selectablesUpdated();
        return that
    };
    fluid.selectable = function (target, options) {
        target = $(target);
        var that = makeElementsSelectable(target, fluid.selectable.defaults, options);
        fluid.setScopedData(target, CONTEXT_KEY, that);
        return that
    };
    fluid.selectable.select = function (target, toSelect) {
        fluid.focus(toSelect)
    };
    fluid.selectable.selectNext = function (target) {
        target = $(target);
        focusNextElement(fluid.getScopedData(target, CONTEXT_KEY))
    };
    fluid.selectable.selectPrevious = function (target) {
        target = $(target);
        focusPreviousElement(fluid.getScopedData(target, CONTEXT_KEY))
    };
    fluid.selectable.currentSelection = function (target) {
        target = $(target);
        var that = fluid.getScopedData(target, CONTEXT_KEY);
        return $(that.selectedElement())
    };
    fluid.selectable.defaults = {direction:fluid.a11y.orientation.VERTICAL, selectablesTabindex:-1, autoSelectFirstItem:true, rememberSelectionState:true, selectableSelector:".selectable", selectableElements:null, onSelect:null, onUnselect:null, onLeaveContainer:null};
    var checkForModifier = function (binding, evt) {
        if (!binding.modifier) {
            return true
        }
        var modifierKey = binding.modifier;
        var isCtrlKeyPresent = modifierKey && evt.ctrlKey;
        var isAltKeyPresent = modifierKey && evt.altKey;
        var isShiftKeyPresent = modifierKey && evt.shiftKey;
        return isCtrlKeyPresent || isAltKeyPresent || isShiftKeyPresent
    };
    var makeActivationHandler = function (binding) {
        return function (evt) {
            var target = evt.target;
            if (!fluid.enabled(evt.target)) {
                return
            }
            var code = evt.which ? evt.which : evt.keyCode;
            if (code === binding.key && binding.activateHandler && checkForModifier(binding, evt)) {
                var event = $.Event("fluid-activate");
                $(evt.target).trigger(event, [binding.activateHandler]);
                if (event.isDefaultPrevented()) {
                    evt.preventDefault()
                }
            }
        }
    };
    var makeElementsActivatable = function (elements, onActivateHandler, defaultKeys, options) {
        var bindings = [];
        $(defaultKeys).each(function (index, key) {
            bindings.push({modifier:null, key:key, activateHandler:onActivateHandler})
        });
        if (options && options.additionalBindings) {
            bindings = bindings.concat(options.additionalBindings)
        }
        fluid.initEnablement(elements);
        for (var i = 0; i < bindings.length; ++i) {
            var binding = bindings[i];
            elements.keydown(makeActivationHandler(binding))
        }
        elements.bind("fluid-activate", function (evt, handler) {
            handler = handler || onActivateHandler;
            return handler ? handler(evt) : null
        })
    };
    fluid.activatable = function (target, fn, options) {
        target = $(target);
        makeElementsActivatable(target, fn, fluid.activatable.defaults.keys, options)
    };
    fluid.activate = function (target) {
        $(target).trigger("fluid-activate")
    };
    fluid.activatable.defaults = {keys:[$.ui.keyCode.ENTER, $.ui.keyCode.SPACE]}
})(jQuery, fluid_1_4);
